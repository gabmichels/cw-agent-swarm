# Memory Access Patterns

This document outlines how memory is accessed throughout the application.

## Primary Access Patterns

### 1. Chat Message Retrieval

**Use Case**: Displaying chat history to users

**Implementation**:
```typescript
// Get recent chat messages for a user
const messages = await getRecentChatMessages({
  userId: 'user_123',
  limit: 50
});

// Filter for specific timeframe
const messages = await getRecentChatMessages({
  userId: 'user_123',
  since: new Date('2023-05-01'),
  until: new Date('2023-05-31')
});
```

**Key Characteristics**:
- Filters out internal messages (`isInternalMessage: true` or `notForChat: true`)
- Orders by timestamp (oldest first for display)
- Transforms to Message objects for the frontend

### 2. Semantic Search

**Use Case**: Finding relevant memories based on content similarity

**Implementation**:
```typescript
// Search across all memory types
const results = await searchMemory(
  null, // All memory types
  "How does nuclear fusion work?",
  { limit: 10 }
);

// Search within a specific memory type
const relevantThoughts = await searchMemory(
  'thought',
  "How does nuclear fusion work?",
  { limit: 5 }
);
```

**Key Characteristics**:
- Uses vector embeddings for semantic similarity
- Combines with tag matching for hybrid search
- Can filter by metadata properties
- Orders by relevance score

### 3. Agent Context Retrieval

**Use Case**: Providing relevant context to agents

**Implementation**:
```typescript
// Get memories by importance
const criticalMemories = await getMemoriesByImportance(
  'critical',
  20
);

// Get causal chain
const causalContext = await traceCausalChain(
  'memory_123',
  { maxDepth: 2, direction: 'both' }
);
```

**Key Characteristics**:
- Often combines multiple memory types
- May filter by importance level
- Often retrieves causal relationships
- Needs both recent and important memories

### 4. Memory Creation

**Use Case**: Storing new information

**Implementation**:
```typescript
// Simple memory addition
const messageId = await addMemory(
  'message',
  "Hello, how can I help you today?",
  { role: 'assistant', userId: 'user_123' }
);

// More complex memory with importance calculation
const documentId = await storeMemory(
  documentText,
  'document',
  'file_upload',
  { title: 'Research Paper', fileType: 'pdf' }
);
```

**Key Characteristics**:
- Often includes embedding generation
- May calculate importance score
- Often generates tags
- Sometimes creates causal links

### 5. Memory Management

**Use Case**: Managing importance and relevance over time

**Implementation**:
```typescript
// Mark memory as used
await trackMemoryUsage('memory_123');

// Increase importance of a memory
await reinforceMemory('memory_456', 'Explicitly marked helpful by user');

// Decay old memories
await decayMemoryImportance({
  decayPercent: 5,
  olderThan: 30 * 24 * 60 * 60 * 1000, // 30 days
  memoryTypes: ['message', 'thought']
});
```

**Key Characteristics**:
- Batch operations on multiple memories
- Time-based operations
- Importance score adjustments
- Usage tracking

## Collection-Specific Access Patterns

### Messages Collection

1. **Chronological Access**: Getting recent messages in time order
2. **User Filtering**: Getting messages for a specific user
3. **Role Filtering**: Getting messages with a specific role (user/assistant)
4. **Attachment Querying**: Finding messages with attachments

### Thoughts Collection

1. **Thought Type Filtering**: Getting specific types (reflection, planning)
2. **Related Memory Retrieval**: Finding thoughts related to a specific memory
3. **Agent-Specific Thoughts**: Getting thoughts generated by a specific agent
4. **Importance-Based Access**: Getting highest importance thoughts

### Documents Collection

1. **Source Filtering**: Getting documents from a specific source
2. **Content Type Filtering**: Getting documents of a specific type (PDF, markdown)
3. **Chunked Document Retrieval**: Getting all chunks of a document
4. **Title/Keyword Search**: Finding documents by title or content

### Tasks Collection

1. **Status Filtering**: Getting tasks with a specific status
2. **Priority Filtering**: Getting tasks with a specific priority
3. **Assignment Filtering**: Getting tasks assigned to a specific agent
4. **Due Date Querying**: Getting tasks due within a timeframe

## Common Query Patterns

### By Metadata Field

```typescript
// Filter by metadata field
const options = {
  filter: {
    'metadata.role': 'user'
  }
};
```

### By Time Range

```typescript
// Get memories from a time range
const filter = {
  'timestamp': {
    $gte: new Date('2023-05-01').toISOString(),
    $lte: new Date('2023-05-31').toISOString()
  }
};
```

### By Multiple Conditions

```typescript
// Combine multiple conditions
const filter = {
  must: [
    { key: 'metadata.role', match: { value: 'assistant' } },
    { key: 'metadata.messageType', match: { value: 'text' } }
  ],
  must_not: [
    { key: 'metadata.isInternalMessage', match: { value: true } }
  ]
};
```

## Issues with Current Access Patterns

1. **Inconsistent Filter Formats**: Different functions use different filter formats
2. **Inefficient Querying**: Sometimes fetches all records and filters in-memory
3. **No Pagination Support**: Limited support for offset-based pagination
4. **Confusing Search Options**: Mixed use of `filter`, `options.filter`, and direct parameters
5. **Missing Index Support**: Not utilizing indexes for common query patterns
6. **No Access Control**: No user permission handling in memory access
7. **Inconsistent Result Mapping**: Different functions return different structures 