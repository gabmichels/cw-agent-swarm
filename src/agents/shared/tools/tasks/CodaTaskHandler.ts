/**
 * CodaTaskHandler.ts - Task-based Coda document creation
 * 
 * This file provides integration between the DefaultAgent task system and Coda document
 * creation. Handles user intents like "Create a document about X" by creating tasks
 * that generate Coda documents in the specified folder from .env configuration.
 */

import { Task, TaskStatus, TaskScheduleType } from '../../../../lib/scheduler/models/Task.model';
import { IdGenerator } from '../../../../utils/ulid';
import { logger } from '../../../../lib/logging';
import { codaIntegration } from '../integrations/coda';
import { createDefaultCodaConfig, CODA_ENV_VARS } from '../config/CodaToolsConfigSchema';

/**
 * Parameters for Coda document creation tasks
 */
export interface CodaDocumentTaskParams {
  /** Title of the document to create */
  title?: string;
  /** Content for the document */
  content: string;
  /** Folder ID for document placement (uses CODA_FOLDER_ID if not specified) */
  folderId?: string;
  /** User context for the document */
  userContext?: {
    userId?: string;
    userName?: string;
    sessionId?: string;
  };
  /** Document type/category */
  documentType?: 'general' | 'report' | 'analysis' | 'meeting-notes' | 'project' | 'research';
  /** Auto-generate title from content if not provided */
  autoTitle?: boolean;
  /** Tags for organization */
  tags?: string[];
  /** Priority level for document creation */
  priority?: 'low' | 'normal' | 'high' | 'urgent';
}

/**
 * Result of Coda document creation task
 */
export interface CodaDocumentTaskResult {
  /** Whether the task completed successfully */
  success: boolean;
  /** Created document ID */
  documentId?: string;
  /** Document name/title */
  documentName?: string;
  /** Browser link to access the document */
  browserLink?: string;
  /** Folder where document was created */
  folderId?: string;
  /** Error message if failed */
  error?: string;
  /** Additional metadata */
  metadata?: {
    contentLength: number;
    createdAt: string;
    autoGenerated: boolean;
    tags?: string[];
  };
}

/**
 * CodaTaskHandler - Handles creation of Coda documents via the task system
 */
export class CodaTaskHandler {
  private readonly config = createDefaultCodaConfig();
  
  constructor() {
    logger.info('CodaTaskHandler initialized', {
      hasApiKey: !!this.config.api.apiKey,
      hasDefaultFolder: !!this.config.folders.defaultFolderId,
      taskIntegrationEnabled: this.config.features.enableTaskIntegration
    });
  }
  
  /**
   * Create a task for Coda document creation
   */
  async createCodaDocumentTask(
    params: CodaDocumentTaskParams,
    userContext?: { userId?: string; userName?: string; sessionId?: string }
  ): Promise<Task> {
    try {
      // Validate required parameters
      if (!params.content) {
        throw new Error('Content is required for document creation task');
      }
      
      // Generate title if not provided
      const title = params.title || (params.autoTitle !== false ? this.extractTitleFromContent(params.content) : undefined);
      if (!title) {
        throw new Error('Title is required when auto-title is disabled');
      }
      
      // Determine priority (0-10 scale)
      const priority = this.mapPriorityToNumber(params.priority || 'normal');
      
      // Create the task
      const task: Task = {
        id: IdGenerator.generate('task').toString(),
        name: `Create Coda Document: ${title}`,
        description: `Create a Coda document titled "${title}" with ${params.content.length} characters of content`,
        scheduleType: TaskScheduleType.EXPLICIT,
        handler: async (): Promise<CodaDocumentTaskResult> => {
          return await this.executeDocumentCreation(params, title, userContext);
        },
        handlerArgs: [],
        status: TaskStatus.PENDING,
        priority,
        scheduledTime: new Date(), // Execute immediately
        dependencies: [],
        createdAt: new Date(),
        updatedAt: new Date(),
        metadata: {
          tags: ['coda', 'document-creation', ...(params.tags || [])],
          type: 'coda_document_creation',
          params: {
            ...params,
            title,
            userContext
          },
          initiatedBy: userContext?.userId || userContext?.userName || 'unknown',
          estimatedDuration: this.estimateTaskDuration(params)
        }
      };
      
      logger.info('Created Coda document creation task', {
        taskId: task.id,
        title,
        contentLength: params.content.length,
        documentType: params.documentType || 'general',
        priority: params.priority || 'normal'
      });
      
      return task;
      
    } catch (error) {
      logger.error('Error creating Coda document task', {
        error: error instanceof Error ? error.message : String(error),
        params: {
          hasTitle: !!params.title,
          contentLength: params.content?.length || 0,
          documentType: params.documentType
        }
      });
      throw error;
    }
  }
  
  /**
   * Execute a Coda document creation task
   */
  async executeDocumentCreation(
    params: CodaDocumentTaskParams,
    title: string,
    userContext?: { userId?: string; userName?: string; sessionId?: string }
  ): Promise<CodaDocumentTaskResult> {
    const startTime = Date.now();
    
    try {
      logger.info('Executing Coda document creation task', {
        title,
        contentLength: params.content.length,
        documentType: params.documentType || 'general'
      });
      
      // Validate API configuration
      if (!this.config.api.apiKey) {
        throw new Error(`Coda API key not configured. Please set ${CODA_ENV_VARS.API_KEY} in your .env file.`);
      }
      
      // Determine target folder
      const targetFolderId = params.folderId 
        || this.config.folders.taskFolderId 
        || this.config.folders.defaultFolderId 
        || process.env[CODA_ENV_VARS.FOLDER_ID];
      
      // Generate enhanced content with metadata
      const enhancedContent = this.enhanceContent(params.content, {
        documentType: params.documentType || 'general',
        userContext,
        createdViaTask: true,
        tags: params.tags
      });
      
      // Create the document
      const doc = await codaIntegration.createDoc(title, enhancedContent);
      
      const result: CodaDocumentTaskResult = {
        success: true,
        documentId: doc.id,
        documentName: doc.name,
        browserLink: doc.browserLink,
        folderId: targetFolderId,
        metadata: {
          contentLength: enhancedContent.length,
          createdAt: new Date().toISOString(),
          autoGenerated: !params.title,
          tags: params.tags
        }
      };
      
      const endTime = Date.now();
      
      logger.info('Coda document creation task completed successfully', {
        documentId: doc.id,
        documentName: doc.name,
        durationMs: endTime - startTime,
        folderId: targetFolderId
      });
      
      return result;
      
    } catch (error) {
      const endTime = Date.now();
      
      logger.error('Error executing Coda document creation task', {
        error: error instanceof Error ? error.message : String(error),
        durationMs: endTime - startTime
      });
      
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error creating Coda document'
      };
    }
  }
  
  /**
   * Check if a user intent should create a Coda document task
   */
  shouldCreateTaskFromIntent(intent: string): {
    shouldCreate: boolean;
    confidence: number;
    extractedParams?: Partial<CodaDocumentTaskParams>;
  } {
    const normalizedIntent = intent.toLowerCase().trim();
    
    // Define patterns that indicate document creation intent
    const documentCreationPatterns = [
      /create\s+(?:a\s+)?document\s+(?:about|on|for)\s+(.+)/i,
      /make\s+(?:a\s+)?document\s+(?:about|on|for)\s+(.+)/i,
      /write\s+(?:a\s+)?document\s+(?:about|on|for)\s+(.+)/i,
      /document\s+(.+)/i,
      /create\s+(?:a\s+)?(?:report|analysis|notes?)\s+(?:about|on|for)\s+(.+)/i,
      /generate\s+(?:a\s+)?document\s+(?:about|on|for)\s+(.+)/i
    ];
    
    // Document type patterns
    const documentTypePatterns = {
      'report': /\b(?:report|summary|overview)\b/i,
      'analysis': /\b(?:analysis|analyze|study|research)\b/i,
      'meeting-notes': /\b(?:meeting|notes|minutes)\b/i,
      'project': /\b(?:project|plan|roadmap)\b/i,
      'research': /\b(?:research|investigation|findings)\b/i
    };
    
    let bestMatch: RegExpMatchArray | null = null;
    let confidence = 0;
    
    // Check for document creation patterns
    for (const pattern of documentCreationPatterns) {
      const match = normalizedIntent.match(pattern);
      if (match) {
        bestMatch = match;
        confidence = 0.8; // High confidence for explicit document creation
        break;
      }
    }
    
    // If no explicit match, check for implicit patterns
    if (!bestMatch && normalizedIntent.includes('document')) {
      confidence = 0.6; // Medium confidence
      bestMatch = [normalizedIntent, normalizedIntent];
    }
    
    if (!bestMatch) {
      return { shouldCreate: false, confidence: 0 };
    }
    
    // Extract parameters
    const topic = bestMatch[1] || normalizedIntent;
    const extractedParams: Partial<CodaDocumentTaskParams> = {
      title: this.generateTitleFromTopic(topic),
      content: this.generateContentFromTopic(topic),
      autoTitle: false, // We're providing a title
      documentType: this.detectDocumentType(normalizedIntent, documentTypePatterns),
      tags: this.extractTags(topic)
    };
    
    // Adjust confidence based on content quality
    if (extractedParams.title && extractedParams.content) {
      confidence = Math.min(confidence + 0.1, 0.9);
    }
    
    logger.debug('Analyzed user intent for Coda document creation', {
      intent: intent.substring(0, 100) + (intent.length > 100 ? '...' : ''),
      shouldCreate: confidence > 0.5,
      confidence,
      extractedTitle: extractedParams.title,
      documentType: extractedParams.documentType
    });
    
    return {
      shouldCreate: confidence > 0.5,
      confidence,
      extractedParams: confidence > 0.5 ? extractedParams : undefined
    };
  }
  
  /**
   * Extract title from content
   */
  private extractTitleFromContent(content: string): string {
    // Try to find first heading
    const headingMatch = content.match(/^#\s+(.+)$/m);
    if (headingMatch && headingMatch[1]) {
      return headingMatch[1].trim();
    }
    
    // Use first meaningful line
    const lines = content.split('\n').filter(line => line.trim().length > 0);
    if (lines.length > 0) {
      const firstLine = lines[0].trim();
      // Remove markdown formatting
      const cleanLine = firstLine.replace(/^#+\s*/, '').replace(/\*\*(.+?)\*\*/g, '$1').replace(/\*(.+?)\*/g, '$1');
      return cleanLine.substring(0, 60) + (cleanLine.length > 60 ? '...' : '');
    }
    
    return `Document - ${new Date().toLocaleDateString()}`;
  }
  
  /**
   * Enhance content with metadata and structure
   */
  private enhanceContent(
    originalContent: string,
    metadata: {
      documentType: string;
      userContext?: { userId?: string; userName?: string; sessionId?: string };
      createdViaTask: boolean;
      tags?: string[];
    }
  ): string {
    const now = new Date();
    
    let enhanced = originalContent;
    
    // Add document header if not present
    if (!enhanced.startsWith('#')) {
      enhanced = `# Document\n\n${enhanced}`;
    }
    
    // Add metadata section
    const metadataSection = [
      '\n---\n',
      '## Document Information\n',
      `- **Created**: ${now.toLocaleString()}`,
      `- **Type**: ${metadata.documentType}`,
      `- **Generated via**: Task System`,
      metadata.userContext?.userName ? `- **Author**: ${metadata.userContext.userName}` : '',
      metadata.tags?.length ? `- **Tags**: ${metadata.tags.join(', ')}` : '',
      '\n---\n'
    ].filter(Boolean).join('\n');
    
    enhanced += metadataSection;
    
    return enhanced;
  }
  
  /**
   * Generate title from topic
   */
  private generateTitleFromTopic(topic: string): string {
    // Clean and capitalize the topic
    const cleanTopic = topic.replace(/[^\w\s-]/g, '').trim();
    const words = cleanTopic.split(/\s+/);
    const titleWords = words.map(word => 
      word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
    );
    
    return titleWords.join(' ');
  }
  
  /**
   * Generate basic content structure from topic
   */
  private generateContentFromTopic(topic: string): string {
    const title = this.generateTitleFromTopic(topic);
    
    return `# ${title}

## Overview

This document covers ${topic.toLowerCase()}.

## Key Points

- [Add key point 1]
- [Add key point 2]
- [Add key point 3]

## Details

[Add detailed information here]

## Conclusion

[Add conclusion or next steps]
`;
  }
  
  /**
   * Detect document type from intent
   */
  private detectDocumentType(
    intent: string,
    patterns: Record<string, RegExp>
  ): CodaDocumentTaskParams['documentType'] {
    for (const [type, pattern] of Object.entries(patterns)) {
      if (pattern.test(intent)) {
        return type as CodaDocumentTaskParams['documentType'];
      }
    }
    return 'general';
  }
  
  /**
   * Extract tags from topic
   */
  private extractTags(topic: string): string[] {
    const commonTags = [
      'important', 'urgent', 'draft', 'review', 'final',
      'meeting', 'project', 'research', 'analysis', 'report'
    ];
    
    const topicWords = topic.toLowerCase().split(/\s+/);
    const tags = commonTags.filter(tag => 
      topicWords.some(word => word.includes(tag) || tag.includes(word))
    );
    
    return tags;
  }
  
  /**
   * Map priority string to number (0-10 scale)
   */
  private mapPriorityToNumber(priority: string): number {
    switch (priority.toLowerCase()) {
      case 'low': return 2;
      case 'high': return 7;
      case 'urgent': return 9;
      default: return 5; // normal
    }
  }
  
  /**
   * Estimate task duration based on content length and complexity
   */
  private estimateTaskDuration(params: CodaDocumentTaskParams): number {
    const baseTime = 5000; // 5 seconds base
    const contentFactor = Math.min(params.content.length / 1000, 10); // Up to 10 seconds for content
    const complexityFactor = params.documentType === 'analysis' ? 2 : 1;
    
    return Math.round(baseTime + (contentFactor * 1000 * complexityFactor));
  }
}

/**
 * Default instance for easy access
 */
export const codaTaskHandler = new CodaTaskHandler();

/**
 * Utility function to create a Coda document task from user intent
 */
export async function createCodaDocumentFromIntent(
  intent: string,
  userContext?: { userId?: string; userName?: string; sessionId?: string }
): Promise<Task | null> {
  const analysis = codaTaskHandler.shouldCreateTaskFromIntent(intent);
  
  if (!analysis.shouldCreate || !analysis.extractedParams) {
    return null;
  }
  
  return await codaTaskHandler.createCodaDocumentTask(
    {
      content: analysis.extractedParams.content || `# ${analysis.extractedParams.title}\n\nPlease add content here.`,
      ...analysis.extractedParams
    },
    userContext
  );
}

/**
 * Integration hook for DefaultAgent's intent processing
 */
export function integrateCodaTaskWithAgent(agent: any): void {
  // This function can be called during agent initialization to register
  // the Coda task handler with the agent's intent processing system
  
  if (typeof agent.registerIntentHandler === 'function') {
    agent.registerIntentHandler('coda_document_creation', {
      handler: codaTaskHandler,
      priority: 10,
      patterns: [
        /create\s+(?:a\s+)?document/i,
        /make\s+(?:a\s+)?document/i,
        /write\s+(?:a\s+)?document/i,
        /document\s+about/i
      ]
    });
    
    logger.info('Coda task handler integrated with agent intent processing');
  } else {
    logger.warn('Agent does not support intent handler registration');
  }
} 