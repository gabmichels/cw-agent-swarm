/**
 * Bootstrap Agents - Load agents from the database into the runtime registry
 * 
 * This module loads all agents from the database and registers them
 * with the runtime agent registry, ensuring that database agents and
 * runtime agents are synchronized.
 */

import { getMemoryServices } from '../memory/services';
import { createAgentMemoryService } from '../memory/services/multi-agent';
import { registerAgent, getAgentById } from './agent-service';
import { logger } from '../../lib/logging';
import { AgentMemoryEntity } from '../memory/schema/agent';
import { AgentBase } from '../../agents/shared/base/AgentBase.interface';
import { ManagerType } from '../../agents/shared/base/managers/ManagerType';
import { SchedulerManager, TaskCreationOptions } from '../../agents/shared/base/managers/SchedulerManager.interface';
import { PlanCreationOptions, PlanCreationResult, PlanExecutionResult, Plan } from '../../agents/shared/base/managers/PlanningManager.interface';

// Import ALL manager implementations
import { DefaultSchedulerManager } from '../../lib/agents/implementations/managers/DefaultSchedulerManager';
import { DefaultAutonomyManager } from '../../agents/shared/autonomy/managers/DefaultAutonomyManager';
import { DefaultAutonomySystem } from '../../agents/shared/autonomy/systems/DefaultAutonomySystem';
import { DefaultMemoryManager } from '../../lib/agents/implementations/managers/DefaultMemoryManager';
import { DefaultPlanningManager } from '../../lib/agents/implementations/managers/DefaultPlanningManager';
import { DefaultToolManager } from '../../lib/agents/implementations/managers/DefaultToolManager';
import { DefaultKnowledgeManager } from '../../lib/agents/implementations/managers/DefaultKnowledgeManager';
import { FileProcessingManager } from '../../lib/agents/implementations/managers/FileProcessingManager';
import { DefaultInputProcessor } from '../../agents/shared/input/managers/DefaultInputProcessor';
import { DefaultOutputProcessor } from '../../agents/shared/output/managers/DefaultOutputProcessor';
import { StatusManager } from '../../agents/shared/status/StatusManager';
import { DefaultResourceManager } from '../../agents/shared/resource/DefaultResourceManager';
import { DefaultReflectionManager } from '../../agents/shared/reflection/managers/DefaultReflectionManager';
import { DefaultNotificationManager } from '../../agents/shared/notifications/DefaultNotificationManager';
import { NotificationChannel } from '../../agents/shared/notifications/interfaces/NotificationManager.interface';
import { v4 as uuidv4 } from 'uuid';


/**
 * Fully capable agent implementation with ALL required managers
 * 
 * This implementation creates a complete agent with all available managers
 * to ensure full functionality and autonomy.
 */
class FullyCapableAgent {
  private id: string;
  private name: string;
  private description: string;
  private managers: Map<ManagerType, any> = new Map();

  constructor(id: string, name: string, description: string) {
    this.id = id;
    this.name = name;
    this.description = description;
    
    // Add ALL managers for full capability
    this.setupManagers();
  }
  
  /**
   * Set up ALL managers to make this a fully capable agent
   */
  private setupManagers(): void {
    try {
      console.log(`üîÑ Setting up ALL managers for agent ${this.id}...`);
      
      // 1. MEMORY MANAGER
      const memoryManager = new DefaultMemoryManager(this as unknown as AgentBase, {
        enabled: true,
        createPrivateScope: true,
        defaultScopeName: `agent-${this.id}-memory`,
        enableAutoPruning: true,
        enableAutoConsolidation: true,
        pruningIntervalMs: 3600000, // 1 hour
        consolidationIntervalMs: 86400000, // 24 hours
        maxMemoryItems: 10000
      });
      
      // 2. PLANNING MANAGER
      const planningManager = new DefaultPlanningManager(this as unknown as AgentBase, {
        enabled: true,
        maxPlans: 100,
        enablePlanOptimization: true,
        enablePlanAdaptation: true,
        enablePlanValidation: true
      });
      
      // 3. TOOL MANAGER
      const toolManager = new DefaultToolManager(this as unknown as AgentBase, {
        enabled: true,
        maxTools: 50,
        enableAutoDiscovery: true,
        allowUnsafeTool: false
      });
      
      // 4. KNOWLEDGE MANAGER
      const knowledgeManager = new DefaultKnowledgeManager(this as unknown as AgentBase, {
        enabled: true,
        enableAutoRefresh: true,
        refreshIntervalMs: 300000,
        maxKnowledgeItems: 1000
      });
      
      // 5. SCHEDULER MANAGER
      const schedulerManager = new DefaultSchedulerManager(this as unknown as AgentBase, {
        enabled: true,
        maxConcurrentTasks: 5,
        maxRetryAttempts: 3,
        defaultTaskTimeoutMs: 30000,
        enableAutoScheduling: true,
        schedulingIntervalMs: 30000, // 30 seconds
        enableTaskPrioritization: true,
        logSchedulingActivity: true, // Enable detailed logging
      });
      
      // Add a debug task for testing scheduler functionality
      setTimeout(() => {
        console.log(`[${this.id}] Creating test scheduled task for agent`);
        schedulerManager.createTask({
          title: "Periodic health check",
          description: "Check system health and report status",
          type: "system_health",
          priority: 0.7,
          metadata: {
            scheduleType: "interval",
            intervalMs: 30000, // Every 30 seconds
            startAfterMs: 5000, // Start after just 5 seconds
            scheduledTime: new Date(Date.now() + 5000), // Explicit scheduled time 5 seconds from now
            isDebugTask: true,
            action: "processUserInput",
            parameters: {
              message: "Run a quick health check and report any issues."
            }
          }
        }).then(taskResult => {
          console.log(`[${this.id}] Test task created: ${JSON.stringify(taskResult)}`);
        }).catch(err => {
          console.error(`[${this.id}] Error creating test task:`, err);
        });
      }, 10000);
      
      // 6. AUTONOMY MANAGER 
      const autonomySystem = new DefaultAutonomySystem(this as unknown as AgentBase, {
        enableAutonomyOnStartup: true,
        enableOpportunityDetection: true,
        maxConcurrentTasks: 3
      });
      
      const autonomyManager = new DefaultAutonomyManager(this as unknown as AgentBase, {
        enabled: true,
        autonomyConfig: {
          enableAutonomyOnStartup: true,
          enableOpportunityDetection: true,
          maxConcurrentTasks: 3
        }
      });
      
      // 7. FILE PROCESSING MANAGER
      const fileProcessingManager = new FileProcessingManager(this as unknown as AgentBase, {
        enabled: true,
        maxFileSizeMb: 10,
        supportedFileTypes: ['txt', 'md', 'json', 'csv', 'xml', 'yaml', 'html', 'js', 'ts'],
        processingTimeoutMs: 60000
      });
      
      // 8. INPUT MANAGER
      const inputManager = new DefaultInputProcessor(this as unknown as AgentBase, {
        enabled: true,
        keepHistoryItems: 100,
        defaultTimeoutMs: 60000
      });
      
      // 9. OUTPUT MANAGER
      const outputManager = new DefaultOutputProcessor(this as unknown as AgentBase, {
        enabled: true,
        outputFormatting: {
          enableMarkdownFormatting: true,
          enableCodeHighlighting: true,
          enableTemplateProcessing: true
        },
        maxHistoryItems: 100,
        defaultOutputTimeoutMs: 30000
      });
      
      // 10. STATUS MANAGER
      const statusManager = new StatusManager(this as unknown as AgentBase, {
        enabled: true,
        maxHistoryItems: 100,
        logStatusChanges: true,
        enableVisualization: true
      });
      
      // 11. RESOURCE MANAGER
      const resourceManager = new DefaultResourceManager(this as unknown as AgentBase, {
        enabled: true,
        resourceLimits: {
          cpu: 1024,
          memory: 1024,
          storage: 1024,
          network: 100
        },
        enableMonitoring: true,
        monitoringIntervalMs: 60000
      });
      
      // 12. REFLECTION MANAGER
      const reflectionManager = new DefaultReflectionManager(this as unknown as AgentBase, {
        enabled: true,
        reflectionFrequencyMs: 3600000, // 1 hour
        maxReflectionDepth: 3,
        keepReflectionHistory: true,
        maxHistoryItems: 50
      });
      
      // 13. NOTIFICATION MANAGER
      const notificationManager = new DefaultNotificationManager();
      
      // Placeholder functions for remaining manager types (MESSAGING, LOGGER, INTEGRATION)
      // that don't have concrete implementations yet
      const createPlaceholderManager = (type: ManagerType, enabled: boolean = true) => {
        return {
          managerId: `${type}-manager-${uuidv4()}`,
          managerType: type,
          enabled: enabled,
          initialize: async () => true,
          shutdown: async () => {},
          getStatus: () => ({ status: 'available', health: { status: 'healthy' } }),
          isEnabled: () => enabled,
          setEnabled: (value: boolean) => { return value; },
          getAgent: () => this as unknown as AgentBase
        };
      };
      
      // Create placeholder managers for remaining types
      const messagingManager = createPlaceholderManager(ManagerType.MESSAGING);
      const loggerManager = createPlaceholderManager(ManagerType.LOGGER);
      const integrationManager = createPlaceholderManager(ManagerType.INTEGRATION);
      
      // Initialize all real managers (not placeholders)
      console.log(`üîÑ Initializing all managers for agent ${this.id}...`);
      
      // Array of promises for initialization
      const initPromises = [
        memoryManager.initialize(),
        planningManager.initialize(),
        toolManager.initialize(),
        knowledgeManager.initialize(),
        schedulerManager.initialize(),
        autonomyManager.initialize(),
        fileProcessingManager.initialize(),
        inputManager.initialize(),
        outputManager.initialize(),
        statusManager.initialize(),
        resourceManager.initialize(),
        reflectionManager.initialize(),
        // Initialize notification manager
        notificationManager.initialize({
          defaultSenderId: this.id,
          channels: [
            {
              type: NotificationChannel.UI,
              name: 'UI Notifications',
              enabled: true,
              config: {}
            },
            {
              type: NotificationChannel.SYSTEM,
              name: 'System Notifications',
              enabled: true,
              config: {}
            }
          ]
        })
      ];
      
      // Initialize all managers and log results
      Promise.all(initPromises)
        .then(results => {
          const successCount = results.filter(success => success).length;
          console.log(`‚úÖ Successfully initialized ${successCount}/${initPromises.length} managers for agent ${this.id}`);
          
          // Enable autonomy if initialization was successful
          if (typeof autonomyManager.setAutonomyMode === 'function') {
            autonomyManager.setAutonomyMode(true).then(enabled => {
              console.log(`‚úÖ Autonomy mode ${enabled ? 'enabled' : 'failed to enable'} for agent ${this.id}`);
            });
          }
        })
        .catch(error => {
          console.error(`‚ùå Error initializing managers for agent ${this.id}:`, error);
        });
      
      // Register ALL managers with the agent
      this.setManager(memoryManager);
      this.setManager(planningManager);
      this.setManager(toolManager);
      this.setManager(knowledgeManager);
      this.setManager(schedulerManager);
      this.setManager(autonomyManager);
      this.setManager(fileProcessingManager);
      this.setManager(inputManager);
      this.setManager(outputManager);
      this.setManager(statusManager);
      this.setManager(resourceManager);
      this.setManager(reflectionManager);
      this.setManager(notificationManager);
      this.setManager(messagingManager);
      this.setManager(loggerManager);
      this.setManager(integrationManager);
      
      console.log(`‚úÖ All managers set up for agent ${this.id}`);
    } catch (error) {
      console.error(`‚ùå Error setting up managers for agent ${this.id}:`, error);
    }
  }

  getAgentId(): string {
    return this.id;
  }

  getId(): string {
    return this.id;
  }

  getName(): string {
    return this.name;
  }

  getType(): string {
    return 'placeholder';
  }

  getDescription(): string {
    return this.description;
  }

  getVersion(): string {
    return '1.0.0';
  }

  getCapabilities(): Promise<string[]> {
    return Promise.resolve([
      'autonomy', 
      'scheduling', 
      'memory', 
      'planning', 
      'tools', 
      'knowledge', 
      'file_processing', 
      'input_processing',
      'output_processing',
      'status_tracking',
      'resource_management',
      'reflection'
    ]);
  }

  getStatus(): { status: string; message?: string } {
    return { status: 'available' };
  }

  async initialize(): Promise<boolean> {
    return true;
  }

  async shutdown(): Promise<void> {
    return Promise.resolve();
  }

  async reset(): Promise<void> {
    return Promise.resolve();
  }

  getManager<T>(type: ManagerType): T | null {
    console.log(`[${this.id}] Requested manager type: ${type}`);
    const manager = this.managers.get(type) || null;
    console.log(`[${this.id}] Manager lookup result: ${manager ? 'found' : 'NOT FOUND'}`);
    return manager as T | null;
    return (this.managers.get(type) || null) as T | null;
  }

  getManagers(): any[] {
    return Array.from(this.managers.values());
  }

  setManager<T>(manager: T): void {
    const managerAny = manager as any;
    if (managerAny && managerAny.managerType) {
      console.log(`[${this.id}] Setting manager type ${managerAny.managerType} with ID ${managerAny.managerId || 'unknown'}`);
      this.managers.set(managerAny.managerType, manager);
      
      // Verify addition
      setTimeout(() => {
        const storedManager = this.managers.get(managerAny.managerType);
        console.log(`[${this.id}] Verification: Manager type ${managerAny.managerType} is ${storedManager ? 'present' : 'MISSING'}`);
      }, 100);
    } else {
      console.log(`[${this.id}] Warning: Attempted to set manager without managerType`);
    }
    const managerAny = manager as any;
    if (managerAny && managerAny.managerType) {
      this.managers.set(managerAny.managerType, manager);
    }
  }

  removeManager(type: ManagerType): void {
    this.managers.delete(type);
  }

  hasManager(type: ManagerType): boolean {
    return this.managers.has(type);
  }

  // Basic placeholder methods
  async processUserInput(message: string, options?: any): Promise<any> {
    return { content: 'Placeholder agent cannot process input' };
  }

  async think(message: string, options?: any): Promise<any> {
    return { success: false, error: 'Placeholder agent cannot think' };
  }

  async getLLMResponse(message: string, options?: any): Promise<any> {
    return { content: 'Placeholder agent cannot generate responses' };
  }

  // Tool-related methods
  registerTool(tool: any): Promise<any> { return Promise.resolve({}); }
  unregisterTool(toolId: string): Promise<boolean> { return Promise.resolve(true); }
  getTool(toolId: string): Promise<any> { return Promise.resolve(null); }
  getTools(): Promise<any[]> { return Promise.resolve([]); }
  setToolEnabled(toolId: string, enabled: boolean): Promise<any> { return Promise.resolve({}); }
  
  // Task-related methods with proper type handling
  createTask(options: Record<string, unknown>): Promise<any> { 
    // Forward to scheduler manager if available
    const schedulerManager = this.getManager<SchedulerManager>(ManagerType.SCHEDULER);
    if (schedulerManager && schedulerManager.createTask) {
      // Type assertion to handle the required fields
      return schedulerManager.createTask(options as unknown as TaskCreationOptions);
    }
    return Promise.resolve({}); 
  }
  
  getTask(taskId: string): Promise<Record<string, unknown> | null> { 
    // Forward to scheduler manager if available
    const schedulerManager = this.getManager<SchedulerManager>(ManagerType.SCHEDULER);
    if (schedulerManager && schedulerManager.getTask) {
      // Cast the result to the expected return type
      return schedulerManager.getTask(taskId).then(task => 
        task ? task as unknown as Record<string, unknown> : null
      );
    }
    return Promise.resolve(null); 
  }
  
  getTasks(): Promise<Record<string, unknown>[]> { 
    // Forward to scheduler manager if available
    const schedulerManager = this.getManager<SchedulerManager>(ManagerType.SCHEDULER);
    if (schedulerManager && schedulerManager.getTasks) {
      // Cast the result to the expected return type
      return schedulerManager.getTasks().then(tasks => 
        tasks.map(task => task as unknown as Record<string, unknown>)
      );
    }
    return Promise.resolve([]); 
  }
  
  executeTask(taskId: string): Promise<any> { 
    // Forward to scheduler manager if available
    const schedulerManager = this.getManager<SchedulerManager>(ManagerType.SCHEDULER);
    if (schedulerManager && schedulerManager.executeTask) {
      return schedulerManager.executeTask(taskId);
    }
    return Promise.resolve({}); 
  }
  
  cancelTask(taskId: string): Promise<boolean> { 
    // Forward to scheduler manager if available
    const schedulerManager = this.getManager<SchedulerManager>(ManagerType.SCHEDULER);
    if (schedulerManager && schedulerManager.cancelTask) {
      return schedulerManager.cancelTask(taskId);
    }
    return Promise.resolve(true); 
  }
  
  retryTask(taskId: string): Promise<any> { 
    // Forward to scheduler manager if available
    const schedulerManager = this.getManager<SchedulerManager>(ManagerType.SCHEDULER);
    if (schedulerManager && schedulerManager.retryTask) {
      return schedulerManager.retryTask(taskId);
    }
    return Promise.resolve({}); 
  }
  
  // Config and status methods
  getConfig(): Record<string, unknown> { return {}; }
  updateConfig(config: Record<string, unknown>): void {}
  isEnabled(): boolean { return true; }
  setEnabled(enabled: boolean): boolean { return true; }
  hasCapability(capabilityId: string): boolean { 
    const capabilities = [
      'autonomy', 
      'scheduling', 
      'memory', 
      'planning', 
      'tools', 
      'knowledge', 
      'file_processing',
      'input_processing',
      'output_processing',
      'status_tracking',
      'resource_management',
      'reflection'
    ];
    return capabilities.includes(capabilityId);
  }
  enableCapability(capability: any): void {}
  disableCapability(capabilityId: string): void {}
  getHealth(): Promise<any> { return Promise.resolve({ status: 'healthy' }); }
  getSchedulerManager(): any { return this.getManager(ManagerType.SCHEDULER); }
  initializeManagers(): Promise<void> { return Promise.resolve(); }
  shutdownManagers(): Promise<void> { return Promise.resolve(); }
  
  // Memory-related methods
  addMemory(content: string, metadata?: Record<string, unknown>): Promise<any> { return Promise.resolve({}); }
  searchMemories(query: string, options?: Record<string, unknown>): Promise<any[]> { return Promise.resolve([]); }
  getRecentMemories(limit?: number): Promise<any[]> { return Promise.resolve([]); }
  consolidateMemories(options?: Record<string, unknown>): Promise<any> { return Promise.resolve({}); }
  getMemoryById(id: string): Promise<any> { return Promise.resolve(null); }
  deleteMemory(id: string): Promise<boolean> { return Promise.resolve(true); }
  pruneMemories(options?: Record<string, unknown>): Promise<any> { return Promise.resolve({}); }
  
  // Plan-related methods with proper type signatures
  createPlan(options: PlanCreationOptions): Promise<PlanCreationResult> { 
    // Create dummy plan with minimal fields to satisfy type
    const dummyPlan: Plan = {
      id: 'placeholder-plan',
      name: 'Placeholder Plan',
      description: 'This is a placeholder plan',
      goals: [],
      steps: [],
      status: 'pending',
      priority: 0,
      confidence: 0,
      createdAt: new Date(),
      updatedAt: new Date(),
      metadata: {}
    };
    
    return Promise.resolve({ 
      success: false, 
      error: 'Placeholder agent cannot create plans',
      plan: undefined
    }); 
  }
  
  executePlan(planId: string): Promise<PlanExecutionResult> { 
    return Promise.resolve({ 
      success: false, 
      error: 'Placeholder agent cannot execute plans'
    }); 
  }
  
  cancelPlan(planId: string): Promise<boolean> { return Promise.resolve(true); }
  getPlans(): Promise<any[]> { return Promise.resolve([]); }
  getAllPlans(): Promise<any[]> { return Promise.resolve([]); }
  getPlan(planId: string): Promise<any> { return Promise.resolve(null); }
  updatePlan(planId: string, updates: Record<string, unknown>): Promise<any> { return Promise.resolve({}); }
  deletePlan(planId: string): Promise<boolean> { return Promise.resolve(true); }
  adaptPlan(planId: string, options: Record<string, unknown>): Promise<any> { return Promise.resolve({}); }
  
  // Knowledge-related methods
  searchKnowledge(query: string): Promise<any[]> { return Promise.resolve([]); }
  getKnowledgeEntities(): Promise<any[]> { return Promise.resolve([]); }
  addKnowledge(content: string, metadata: Record<string, unknown>): Promise<any> { return Promise.resolve({}); }
  updateKnowledge(id: string, updates: Record<string, unknown>): Promise<any> { return Promise.resolve({}); }
  deleteKnowledge(id: string): Promise<boolean> { return Promise.resolve(true); }
  
  // Skill-related methods
  executeSkill(skillId: string, parameters: Record<string, unknown>): Promise<any> { return Promise.resolve({}); }
  getSkills(): Promise<any[]> { return Promise.resolve([]); }
  getSkill(skillId: string): Promise<any> { return Promise.resolve(null); }
  registerSkill(skill: any): Promise<any> { return Promise.resolve({}); }
  
  // Additional methods required by the base interface
  reflect(options?: Record<string, unknown>): Promise<any> { return Promise.resolve({}); }
  learn(content: string, options?: Record<string, unknown>): Promise<any> { return Promise.resolve({}); }
  explain(query: string, options?: Record<string, unknown>): Promise<any> { return Promise.resolve({}); }
  summarize(content: string, options?: Record<string, unknown>): Promise<any> { return Promise.resolve({}); }
  analyze(content: string, options?: Record<string, unknown>): Promise<any> { return Promise.resolve({}); }
  createAssistant(config: Record<string, unknown>): Promise<any> { return Promise.resolve({}); }
  delegate(task: Record<string, unknown>, agentId: string): Promise<any> { return Promise.resolve({}); }
  collaborate(task: Record<string, unknown>, agentIds: string[]): Promise<any> { return Promise.resolve({}); }
  negotiate(proposal: Record<string, unknown>, counterpartyId: string): Promise<any> { return Promise.resolve({}); }
  integrateWithPlatform(platformId: string, config: Record<string, unknown>): Promise<any> { return Promise.resolve({}); }
  requestFeedback(taskId: string): Promise<any> { return Promise.resolve({}); }
  generateText(prompt: string, options?: Record<string, unknown>): Promise<any> { return Promise.resolve({}); }
  generateCode(spec: string, options?: Record<string, unknown>): Promise<any> { return Promise.resolve({}); }
  generateImage(prompt: string, options?: Record<string, unknown>): Promise<any> { return Promise.resolve({}); }
  detectIntent(input: string): Promise<any> { return Promise.resolve({}); }
  extractEntities(input: string): Promise<any> { return Promise.resolve({}); }
  classifyContent(input: string, categories: string[]): Promise<any> { return Promise.resolve({}); }
  answerQuestion(question: string, options?: Record<string, unknown>): Promise<any> { return Promise.resolve({}); }
}

/**
 * Bootstrap all agents from the database into the runtime registry
 * 
 * @returns Promise resolving to the number of agents loaded
 */
export async function bootstrapAgentsFromDatabase(): Promise<number> {
  console.log("=== SCHEDULER DEBUG: bootstrapAgentsFromDatabase called ===");

  try {
    logger.info('Bootstrapping agents from database into runtime registry...');
    console.log('ü§ñ Starting agent bootstrap process...');
    
    // Get memory service
    const { memoryService } = await getMemoryServices();
    const agentService = await createAgentMemoryService(memoryService);
    
    // Get all agents from database
    const getResult = await agentService.getAgents();
    
    if (getResult.isError || !getResult.value) {
      logger.error('Failed to load agents from database:', getResult.error?.message);
      console.error('‚ùå Failed to load agents from database:', getResult.error?.message);
      return 0;
    }
    
    const dbAgents = getResult.value;
    logger.info(`Found ${dbAgents.length} agents in database`);
    console.log(`üìã Found ${dbAgents.length} agents in database`);
    
    // Log all available agents in database
    console.log('üìù Agents available in database:');
    dbAgents.forEach((agent: AgentMemoryEntity) => {
      console.log(`   - Agent ID: ${agent.id}, Name: ${agent.name}`);
    });
    
    let loadedCount = 0;
    
    // Load and register each agent
    for (const dbAgent of dbAgents) {
      try {
        // Skip if agent is already registered
        if (getAgentById(dbAgent.id)) {
          logger.info(`Agent ${dbAgent.id} already registered, skipping`);
          console.log(`‚è© Agent ${dbAgent.id} (${dbAgent.name}) already registered, skipping`);
          continue;
        }
        
        // Debug log
        console.log(`üîç Creating fully-capable agent for ${dbAgent.id} (${dbAgent.name})...`);
        
        // Create a fully capable agent with ALL managers
        const agent = new FullyCapableAgent(
          dbAgent.id,
          dbAgent.name || 'Unnamed Agent',
          dbAgent.description || ''
        );
        
        // Verify ID is set correctly
        const agentId = agent.getAgentId();
        if (agentId !== dbAgent.id) {
          throw new Error(`Agent ID mismatch: got ${agentId}, expected ${dbAgent.id}`);
        }
        
        console.log(`‚úì Agent ID verified: ${agentId}`);
        
        // Initialize the agent
        console.log(`üîÑ Initializing agent ${agentId}...`);
        await agent.initialize();
        
        // Register with runtime registry (use type assertion to bypass type checking)
        console.log(`üìù Registering agent ${agentId} with runtime registry...`);
        registerAgent(agent as unknown as AgentBase);
        logger.info(`Registered agent ${dbAgent.id} (${dbAgent.name}) in runtime registry`);
        console.log(`‚úÖ Registered agent ${dbAgent.id} (${dbAgent.name}) in runtime registry as fully-capable agent with ALL managers`);
        
        loadedCount++;
      } catch (error) {
        logger.error(`Error bootstrapping agent ${dbAgent.id}:`, error);
        console.error(`‚ùå Error bootstrapping agent ${dbAgent.id} (${dbAgent.name}):`, error);
      }
    }
    
    logger.info(`Successfully bootstrapped ${loadedCount} agents from database into runtime registry`);
    console.log(`üöÄ Successfully bootstrapped ${loadedCount} agents from database into runtime registry`);
    return loadedCount;
  } catch (error) {
    logger.error('Error bootstrapping agents from database:', error);
    console.error('‚ùå Error bootstrapping agents from database:', error);
    return 0;
  }
} 