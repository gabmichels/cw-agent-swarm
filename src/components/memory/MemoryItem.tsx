import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { Tag, Info, Calendar, Clock, ChevronDown, ChevronUp, Edit, RefreshCw, RotateCcw } from 'lucide-react';
import SuggestedTagsApproval from '../tags/SuggestedTagsApproval';
import { MemoryItem as MemoryItemType } from '../../types';

// Define memory edit record type to match the backend
interface MemoryEditRecord {
  id: string;
  text: string;
  timestamp: string;
  type: string;
  metadata: Record<string, any>;
  original_memory_id: string;
  edit_type: 'create' | 'update' | 'delete';
  editor_type: 'human' | 'agent' | 'system';
  editor_id?: string;
  diff_summary?: string;
  current: boolean;
  previous_version_id?: string;
}

// Related version interface
interface RelatedVersion {
  id: string;
  type: string;
  timestamp: string;
  text?: string;
  content?: string;
  error?: boolean;
}

interface MemoryItemProps {
  memory: MemoryItemType & {
    kind?: string;
    metadata?: Record<string, any>;
  };
  onTagUpdate: (memoryId: string, tags: string[]) => void;
  onTagSuggestionRemove: (memoryId: string) => void;
}

/**
 * Component for displaying a single memory item with tag approval
 */
const MemoryItem: React.FC<MemoryItemProps> = ({
  memory,
  onTagUpdate,
  onTagSuggestionRemove
}) => {
  const [expanded, setExpanded] = useState(false);
  const [showSuggestions, setShowSuggestions] = useState(true);
  const [historyExpanded, setHistoryExpanded] = useState(false);
  const [memoryHistory, setMemoryHistory] = useState<MemoryEditRecord[]>([]);
  const [isLoadingHistory, setIsLoadingHistory] = useState(false);
  const [selectedVersion, setSelectedVersion] = useState<RelatedVersion | null>(null);
  const [isLoadingVersion, setIsLoadingVersion] = useState(false);
  
  // Check if this memory has auto-generated tags that need approval
  const hasAutoGeneratedTags = memory.metadata?.autoGeneratedTags === true;
  
  // Extract suggested tags vs. manually added tags
  const manualTags = hasAutoGeneratedTags 
    ? memory.tags?.filter(tag => !(memory.metadata?.suggestedTags || []).includes(tag)) || []
    : memory.tags || [];
  
  const suggestedTags = hasAutoGeneratedTags 
    ? (memory.metadata?.suggestedTags || []).filter(Boolean)
    : [];

  // Ensure we have a valid ID
  const memoryId = memory.id || `memory-${Date.now()}`;

  // Create a current version object for reference
  const currentVersion: RelatedVersion = {
    id: memoryId,
    type: memory.kind || memory.metadata?.type || 'unknown',
    timestamp: memory.created || memory.timestamp || new Date().toISOString(),
    text: memory.content
  };

  // Format date for history items
  const formatHistoryDate = (timestamp: string) => {
    try {
      return new Date(timestamp).toLocaleString();
    } catch (e) {
      return timestamp;
    }
  };
  
  // Get all related versions from metadata
  const relatedVersions = memory.metadata?.related_versions 
    ? (memory.metadata.related_versions as RelatedVersion[])
    : [];

  // Fetch memory history from the API
  const loadMemoryHistory = useCallback(async () => {
    if (!memoryId || memoryId.startsWith('memory-')) return;
    
    setIsLoadingHistory(true);
    try {
      const response = await fetch(`/api/memory/history?id=${memoryId}`);
      if (response.ok) {
        const data = await response.json();
        setMemoryHistory(data);
      } else {
        console.error('Failed to load memory history');
      }
    } catch (error) {
      console.error('Error loading memory history:', error);
    } finally {
      setIsLoadingHistory(false);
    }
  }, [memoryId]);
  
  // Load a specific version of a memory
  const loadVersionContent = async (versionId: string) => {
    if (!versionId || versionId.startsWith('memory-')) return null;
    
    setIsLoadingVersion(true);
    try {
      // Use search endpoint to find the specific memory by ID
      const response = await fetch(`/api/memory/search?id=${versionId}`);
      if (response.ok) {
        const data = await response.json();
        console.log('Loaded version data:', data);
        
        // Check if we got a valid response with data
        if (data && Array.isArray(data) && data.length > 0) {
          // Check if the response contains an error object
          if (data[0].metadata?.error) {
            console.error('Server returned error:', data[0].text);
            return { 
              content: `Error loading content: ${data[0].text}`,
              id: versionId,
              metadata: { error: true }
            };
          }
          return data[0];
        } else {
          console.warn(`No data returned for version ID: ${versionId}`);
          return { 
            content: 'Content not available for this version',
            id: versionId,
            metadata: { notFound: true }
          };
        }
      } else {
        console.error('Failed to load version content, status:', response.status);
        return { 
          content: `Failed to load content (status: ${response.status})`,
          id: versionId,
          metadata: { error: true, status: response.status }
        };
      }
    } catch (error) {
      console.error('Error loading version content:', error);
      return { 
        content: `Error loading content: ${error instanceof Error ? error.message : 'Unknown error'}`,
        id: versionId,
        metadata: { error: true }
      };
    } finally {
      setIsLoadingVersion(false);
    }
  };

  // Preload content for all related versions
  const preloadRelatedVersionsContent = useCallback(async () => {
    // Only preload if we have versions without content
    const versionsNeedingContent = relatedVersions.filter(v => !v.text && !v.content);
    
    if (versionsNeedingContent.length === 0) return;
    
    console.log(`Preloading content for ${versionsNeedingContent.length} related versions`);
    
    // Create a new array to avoid modifying the state directly during iteration
    const updatedVersions = [...relatedVersions];
    
    // Load content for each version without showing loading state for better UX
    for (const version of versionsNeedingContent) {
      try {
        const response = await fetch(`/api/memory/search?id=${version.id}`);
        if (response.ok) {
          const data = await response.json();
          if (data && Array.isArray(data) && data.length > 0) {
            // Find the index in our copy of the array
            const versionIndex = updatedVersions.findIndex(v => v.id === version.id);
            
            if (versionIndex >= 0) {
              const content = data[0].content || data[0].text || 'No content available';
              updatedVersions[versionIndex] = {
                ...updatedVersions[versionIndex],
                text: content
              };
              console.log(`Preloaded content for version ${version.id}`);
            }
          } else {
            console.warn(`No data returned for version ID: ${version.id} during preload`);
          }
        }
      } catch (error) {
        console.error(`Error preloading content for version ${version.id}:`, error);
      }
    }
    
    // Update all related versions at once (more React-friendly)
    // This is a mutable update but only for preloading, not rendering directly
    for (let i = 0; i < updatedVersions.length; i++) {
      if (updatedVersions[i].text && !relatedVersions[i].text) {
        relatedVersions[i].text = updatedVersions[i].text;
      }
    }
  }, [relatedVersions]);

  // The content to display (either current or selected version)
  const displayContent = useMemo(() => {
    if (selectedVersion) {
      // If selected version has an error, display it with an error indicator
      if (selectedVersion.error) {
        return {
          content: selectedVersion.text || selectedVersion.content || 'Error loading content',
          isError: true
        };
      }
      return {
        content: selectedVersion.text || selectedVersion.content || 'No content available',
        isError: false
      };
    }
    // Default to current memory content
    return {
      content: memory.content,
      isError: false
    };
  }, [selectedVersion, memory.content]);
  
  // Load memory history when expanding history section
  useEffect(() => {
    if (historyExpanded) {
      if (memoryHistory.length === 0) {
        loadMemoryHistory();
      }
      
      // Pre-load related version content for better user experience
      if (relatedVersions.length > 0) {
        preloadRelatedVersionsContent();
      }
    }
  }, [historyExpanded, memoryHistory.length, relatedVersions.length, loadMemoryHistory, preloadRelatedVersionsContent]);

  // Handle selecting a different version to display
  const handleSelectVersion = async (version: RelatedVersion) => {
    // If this is the version we're already showing, don't do anything
    if (selectedVersion?.id === version.id) {
      return;
    }
    
    // If we already have the text, just select it
    if (version.text || version.content) {
      console.log('Using cached version content:', version);
      setSelectedVersion(version);
      return;
    }
    
    console.log('Loading version content for:', version.id);
    
    // Otherwise, we need to fetch the content
    try {
      const versionContent = await loadVersionContent(version.id);
      
      if (versionContent) {
        // Even if there's an error, we'll display it to the user
        // Update the version with the content - handle both text and content properties
        const updatedVersion: RelatedVersion = {
          ...version,
          text: versionContent.content || versionContent.text || 'No content available',
          // Add error flag if the content represents an error
          error: versionContent.metadata?.error || false
        };
        
        console.log('Setting selected version to:', updatedVersion);
        setSelectedVersion(updatedVersion);
        
        // Also update the text in the original relatedVersions array for future use
        // Make a copy to avoid direct state mutation issues
        const updatedRelatedVersions = [...relatedVersions];
        const versionIndex = updatedRelatedVersions.findIndex(v => v.id === version.id);
        
        if (versionIndex >= 0) {
          updatedRelatedVersions[versionIndex] = {
            ...updatedRelatedVersions[versionIndex],
            text: updatedVersion.text,
            error: updatedVersion.error
          };
          
          // Update the mutable array used for caching
          relatedVersions[versionIndex].text = updatedVersion.text;
          if (updatedVersion.error) {
            relatedVersions[versionIndex].error = true;
          }
        }
      } else {
        // Handle null response - shouldn't happen with our improved loadVersionContent
        console.error('Failed to load content for version (null response):', version.id);
        setSelectedVersion({
          ...version,
          text: 'Failed to load content - please try again',
          error: true
        });
      }
    } catch (error) {
      // Catch any unexpected errors during selection process
      console.error('Error selecting version:', error);
      setSelectedVersion({
        ...version,
        text: `Error loading content: ${error instanceof Error ? error.message : 'Unknown error'}`,
        error: true
      });
    }
  };

  // Reset to the current version
  const resetToCurrentVersion = () => {
    setSelectedVersion(null);
  };

  // Handle tag approval
  const handleTagApproval = (memoryId: string, approvedTags: string[]) => {
    // Combine manually added tags with approved tags
    const updatedTags = [...manualTags, ...approvedTags];
    
    // Update tags via parent component
    onTagUpdate(memoryId, updatedTags);
    
    // Hide the suggestions UI
    setShowSuggestions(false);
  };
  
  // Handle tag suggestion rejection
  const handleTagRejection = (memoryId: string) => {
    onTagSuggestionRemove(memoryId);
    setShowSuggestions(false);
  };
  
  // Format the created date
  const formattedDate = memory.created 
    ? new Date(memory.created).toLocaleString()
    : memory.timestamp
    ? new Date(memory.timestamp).toLocaleString()
    : 'Unknown date';

  // Group metadata by categories for better organization
  const groupedMetadata = React.useMemo(() => {
    if (!memory.metadata) return {};

    // Define metadata categories
    const groups = {
      importance: ['importance', 'importance_score'],
      tags: ['tagsApproved', 'tagConfidence', 'extractedTags'],
      timestamps: ['timestamp', 'created_at', 'updated_at', 'last_updated'],
      content: ['type', 'source', 'role', 'messageType'],
      usage: ['usage_count', 'last_used', 'reinforced', 'last_reinforced_at'],
      status: ['is_deleted', 'current', 'deletion_timestamp'],
      relations: ['previous_version_id', 'led_to', 'caused_by', 'related_versions'],
      editor: ['editor_type', 'editor_id'],
      other: [] as string[]
    };

    // Map for categorizing metadata keys
    const keyToGroup: Record<string, keyof typeof groups> = {};
    
    // Initialize keyToGroup mapping
    Object.entries(groups).forEach(([groupName, keys]) => {
      keys.forEach(key => {
        keyToGroup[key] = groupName as keyof typeof groups;
      });
    });

    // Group metadata by category
    const result: Record<string, Record<string, any>> = {
      importance: {},
      tags: {},
      timestamps: {},
      content: {},
      usage: {},
      status: {},
      relations: {},
      editor: {},
      other: {}
    };

    // Skip these keys from display
    const skippedKeys = ['autoGeneratedTags', 'suggestedTags', '_skip_logging'];

    Object.entries(memory.metadata).forEach(([key, value]) => {
      if (skippedKeys.includes(key)) return;
      
      // Determine which group this key belongs to
      const group = keyToGroup[key] || 'other';
      
      // Add to the appropriate group
      result[group][key] = value;
      
      // If we didn't have a predefined group, remember this key for 'other' category
      if (group === 'other' && !groups.other.includes(key)) {
        groups.other.push(key);
      }
    });

    return result;
  }, [memory.metadata]);

  return (
    <div className="border border-gray-700 rounded-lg bg-gray-800 p-4 mb-4">
      {/* Memory header */}
      <div className="flex justify-between items-start mb-2">
        <div className="flex items-center">
          {memory.category && (
            <span className="mr-2 px-2 py-1 bg-blue-900 text-blue-100 rounded-md text-xs">
              {memory.category}
            </span>
          )}
          {(selectedVersion ? selectedVersion.type : memory.kind) && (
            <span className="mr-2 px-2 py-1 bg-purple-900 text-purple-100 rounded-md text-xs">
              {selectedVersion ? selectedVersion.type : memory.kind}
            </span>
          )}
          <span className="text-gray-400 text-xs flex items-center">
            <Calendar className="h-3 w-3 mr-1" /> 
            {selectedVersion ? formatHistoryDate(selectedVersion.timestamp) : formattedDate}
          </span>
          
          {/* Show older version indicator if a non-current version is selected */}
          {selectedVersion && (
            <span className="ml-2 px-2 py-0.5 bg-orange-800 text-orange-100 rounded text-xs font-medium">
              OLDER VERSION
            </span>
          )}
        </div>
        
        <div className="flex items-center gap-2">
          {/* Reset button when viewing an older version */}
          {selectedVersion && (
            <button
              onClick={resetToCurrentVersion}
              className="text-blue-400 text-xs hover:text-blue-300 flex items-center"
            >
              <RotateCcw className="h-3 w-3 mr-1" /> Current
            </button>
          )}
          
          <button
            onClick={() => setExpanded(!expanded)}
            className="text-blue-400 text-sm hover:underline flex items-center"
          >
            {expanded ? 'Show Less' : 'Show More'}
            {expanded ? <ChevronUp className="h-3 w-3 ml-1" /> : <ChevronDown className="h-3 w-3 ml-1" />}
          </button>
        </div>
      </div>
      
      {/* Memory content */}
      <div className={`mb-3 ${expanded ? '' : 'line-clamp-3'}`}>
        {isLoadingVersion ? (
          <div className="flex justify-center items-center p-4">
            <RefreshCw className="h-4 w-4 animate-spin text-blue-400 mr-2" />
            <span className="text-sm text-gray-400">Loading version...</span>
          </div>
        ) : displayContent.isError ? (
          <div className="p-2 bg-red-950/30 border border-red-900 rounded">
            <p className="text-sm text-red-300">{displayContent.content}</p>
          </div>
        ) : (
          <p className="text-sm">{displayContent.content}</p>
        )}
      </div>
      
      {/* Display existing tags */}
      {manualTags.length > 0 && !selectedVersion && (
        <div className="mb-3">
          <div className="flex items-center text-xs text-gray-400 mb-1">
            <Tag className="h-3 w-3 mr-1" /> Tags:
          </div>
          <div className="flex flex-wrap gap-1">
            {manualTags.map((tag, index) => (
              <span
                key={`${tag}-${index}`}
                className="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-700 text-gray-200"
              >
                {tag}
              </span>
            ))}
          </div>
        </div>
      )}
      
      {/* Display suggested tags for approval if they exist */}
      {hasAutoGeneratedTags && suggestedTags.length > 0 && showSuggestions && !selectedVersion && (
        <SuggestedTagsApproval
          memoryId={memoryId}
          suggestedTags={suggestedTags}
          existingTags={manualTags}
          onApprove={handleTagApproval}
          onReject={handleTagRejection}
        />
      )}
      
      {/* Metadata section (only when expanded) */}
      {expanded && memory.metadata && Object.keys(memory.metadata).length > 0 && (
        <div className="mt-3 border-t border-gray-700 pt-2">
          <div className="flex items-center text-xs text-gray-400 mb-2">
            <Info className="h-3 w-3 mr-1" /> Metadata:
          </div>
          
          <div className="space-y-3">
            {/* Importance info */}
            {Object.keys(groupedMetadata.importance).length > 0 && (
              <div className="bg-gray-850 rounded p-2">
                <h4 className="text-xs font-semibold text-gray-300 mb-1">Importance</h4>
                <div className="grid grid-cols-2 gap-x-4 gap-y-1">
                  {Object.entries(groupedMetadata.importance).map(([key, value]) => (
                    <div key={key} className="text-xs">
                      <span className="text-gray-400">{key}: </span>
                      <span className="text-gray-200">
                        {typeof value === 'number' ? value.toFixed(2) : String(value)}
                      </span>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Content info */}
            {Object.keys(groupedMetadata.content).length > 0 && (
              <div className="bg-gray-850 rounded p-2">
                <h4 className="text-xs font-semibold text-gray-300 mb-1">Content</h4>
                <div className="grid grid-cols-2 gap-x-4 gap-y-1">
                  {Object.entries(groupedMetadata.content).map(([key, value]) => (
                    <div key={key} className="text-xs">
                      <span className="text-gray-400">{key}: </span>
                      <span className="text-gray-200">{String(value)}</span>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Status info */}
            {Object.keys(groupedMetadata.status).length > 0 && (
              <div className="bg-gray-850 rounded p-2">
                <h4 className="text-xs font-semibold text-gray-300 mb-1">Status</h4>
                <div className="grid grid-cols-2 gap-x-4 gap-y-1">
                  {Object.entries(groupedMetadata.status).map(([key, value]) => (
                    <div key={key} className="text-xs">
                      <span className="text-gray-400">{key}: </span>
                      <span className="text-gray-200">{typeof value === 'boolean' ? (value ? 'Yes' : 'No') : String(value)}</span>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Tags info */}
            {Object.keys(groupedMetadata.tags).length > 0 && (
              <div className="bg-gray-850 rounded p-2">
                <h4 className="text-xs font-semibold text-gray-300 mb-1">Tag Information</h4>
                <div className="grid grid-cols-2 gap-x-4 gap-y-1">
                  {Object.entries(groupedMetadata.tags).map(([key, value]) => (
                    <div key={key} className="text-xs">
                      <span className="text-gray-400">{key}: </span>
                      <span className="text-gray-200">
                        {key === 'tagConfidence' && typeof value === 'number' 
                          ? value.toFixed(2) 
                          : typeof value === 'boolean' 
                            ? (value ? 'Yes' : 'No')
                            : String(value)}
                      </span>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Usage info */}
            {Object.keys(groupedMetadata.usage).length > 0 && (
              <div className="bg-gray-850 rounded p-2">
                <h4 className="text-xs font-semibold text-gray-300 mb-1">Usage</h4>
                <div className="grid grid-cols-2 gap-x-4 gap-y-1">
                  {Object.entries(groupedMetadata.usage).map(([key, value]) => (
                    <div key={key} className="text-xs">
                      <span className="text-gray-400">{key}: </span>
                      <span className="text-gray-200">{String(value)}</span>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Timestamps */}
            {Object.keys(groupedMetadata.timestamps).length > 0 && (
              <div className="bg-gray-850 rounded p-2">
                <h4 className="text-xs font-semibold text-gray-300 mb-1">Timestamps</h4>
                <div className="grid grid-cols-1 gap-y-1">
                  {Object.entries(groupedMetadata.timestamps).map(([key, value]) => (
                    <div key={key} className="text-xs">
                      <span className="text-gray-400">{key}: </span>
                      <span className="text-gray-200">{String(value)}</span>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Relations */}
            {Object.keys(groupedMetadata.relations).length > 0 && (
              <div className="bg-gray-850 rounded p-2">
                <h4 className="text-xs font-semibold text-gray-300 mb-1">Memory Relations</h4>
                <div className="grid grid-cols-1 gap-y-1">
                  {Object.entries(groupedMetadata.relations).map(([key, value]) => (
                    <div key={key} className="text-xs">
                      <span className="text-gray-400">{key}: </span>
                      <span className="text-gray-200">
                        {typeof value === 'object' ? JSON.stringify(value) : String(value)}
                      </span>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Editor */}
            {Object.keys(groupedMetadata.editor).length > 0 && (
              <div className="bg-gray-850 rounded p-2">
                <h4 className="text-xs font-semibold text-gray-300 mb-1">Edited By</h4>
                <div className="grid grid-cols-2 gap-x-4 gap-y-1">
                  {Object.entries(groupedMetadata.editor).map(([key, value]) => (
                    <div key={key} className="text-xs">
                      <span className="text-gray-400">{key}: </span>
                      <span className="text-gray-200">{String(value)}</span>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Other fields */}
            {Object.keys(groupedMetadata.other).length > 0 && (
              <div className="bg-gray-850 rounded p-2">
                <h4 className="text-xs font-semibold text-gray-300 mb-1">Other Metadata</h4>
                <div className="grid grid-cols-2 gap-x-4 gap-y-1">
                  {Object.entries(groupedMetadata.other).map(([key, value]) => (
                    <div key={key} className="text-xs">
                      <span className="text-gray-400">{key}: </span>
                      <span className="text-gray-200">
                        {typeof value === 'object' ? JSON.stringify(value) : String(value)}
                      </span>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
          
          {/* Memory history section */}
          <div className="mt-4 border-t border-gray-700 pt-3">
            <button 
              onClick={() => setHistoryExpanded(!historyExpanded)}
              className="flex items-center justify-between w-full text-xs text-blue-400 hover:text-blue-300"
            >
              <div className="flex items-center">
                <Clock className="h-3 w-3 mr-1" /> 
                <span>View Memory History</span>
                {memory.metadata?.related_versions && (
                  <span className="ml-2 px-1.5 py-0.5 bg-blue-900 text-blue-100 rounded-full text-xs">
                    {(memory.metadata.related_versions as any[]).length + 1}
                  </span>
                )}
              </div>
              {historyExpanded ? <ChevronUp className="h-3 w-3" /> : <ChevronDown className="h-3 w-3" />}
            </button>
            
            {historyExpanded && (
              <div className="mt-2">
                {/* Check for related versions first */}
                {relatedVersions.length > 0 && (
                  <div className="bg-yellow-900/30 border border-yellow-800 rounded p-2 mb-2 text-xs">
                    <div className="font-medium text-yellow-300 mb-1">Related Versions Found</div>
                    <p className="text-gray-300 mb-2">
                      This memory exists in multiple forms. The versions below may represent different instances of the same content:
                    </p>
                    <div className="space-y-1.5">
                      {/* Current version (acts as a button to reset to current) */}
                      <button 
                        onClick={() => resetToCurrentVersion()}
                        className={`w-full text-left bg-${selectedVersion ? 'gray-850 hover:bg-blue-900/20' : 'blue-900/30 border border-blue-800'} rounded p-1.5 flex justify-between transition-colors`}
                      >
                        <div className="flex items-center">
                          <span className={`${selectedVersion ? 'text-gray-300' : 'text-blue-300 font-medium'}`}>
                            Current ({currentVersion.type})
                          </span>
                        </div>
                        <span className="text-gray-400">{formatHistoryDate(currentVersion.timestamp)}</span>
                      </button>
                      
                      {/* Related versions - clickable */}
                      {relatedVersions.map((version, idx) => (
                        <button
                          key={idx} 
                          onClick={() => handleSelectVersion(version)}
                          className={`w-full text-left ${selectedVersion?.id === version.id ? 'bg-blue-900/30 border border-blue-800' : 'bg-gray-850 hover:bg-blue-900/20'} rounded p-1.5 flex justify-between transition-colors`}
                        >
                          <div className="flex items-center">
                            <span className={`${selectedVersion?.id === version.id ? 'text-blue-300 font-medium' : 'text-gray-300'}`}>
                              {version.type}
                            </span>
                          </div>
                          <span className="text-gray-400">
                            {version.timestamp ? formatHistoryDate(version.timestamp) : 'Unknown date'}
                          </span>
                        </button>
                      ))}
                    </div>
                  </div>
                )}
              
                {isLoadingHistory ? (
                  <div className="flex justify-center p-4">
                    <RefreshCw className="h-5 w-5 animate-spin text-blue-400" />
                  </div>
                ) : memoryHistory.length > 0 ? (
                  <div className="space-y-2 mt-2 max-h-96 overflow-y-auto">
                    {memoryHistory.map((historyItem, index) => (
                      <div key={index} className={`p-2 rounded text-xs ${historyItem.current ? 'bg-blue-900/30 border border-blue-800' : 'bg-gray-850'}`}>
                        <div className="flex justify-between mb-1">
                          <div className="flex items-center">
                            <Edit className="h-3 w-3 mr-1 text-gray-400" />
                            <span className={`font-medium ${historyItem.current ? 'text-blue-400' : 'text-gray-300'}`}>
                              {historyItem.edit_type.charAt(0).toUpperCase() + historyItem.edit_type.slice(1)}
                              {historyItem.current && " (Current)"}
                            </span>
                          </div>
                          <div className="text-gray-400">
                            {formatHistoryDate(historyItem.timestamp)}
                          </div>
                        </div>
                        
                        <div className="mb-1">
                          <span className="text-gray-400">By: </span>
                          <span className="text-gray-200">
                            {historyItem.editor_type} {historyItem.editor_id ? `(${historyItem.editor_id})` : ''}
                          </span>
                        </div>
                        
                        {historyItem.diff_summary && (
                          <div className="mb-1">
                            <span className="text-gray-400">Changes: </span>
                            <span className="text-gray-200">{historyItem.diff_summary}</span>
                          </div>
                        )}
                        
                        <div className="mt-1 pt-1 border-t border-gray-700">
                          <div className="line-clamp-2 text-gray-300">{historyItem.text}</div>
                        </div>
                      </div>
                    ))}
                  </div>
                ) : !memory.metadata?.related_versions ? (
                  <div className="text-center text-gray-400 text-xs p-3">
                    No history found for this memory
                  </div>
                ) : null}
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
};

export default MemoryItem; 