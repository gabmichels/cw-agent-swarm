import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { Tag, Info, Calendar, Clock, ChevronDown, ChevronUp, Edit, RefreshCw, RotateCcw, Sparkles } from 'lucide-react';
import { MemoryType } from '../../server/memory/config/types';
import { BaseMemorySchema, MemoryPoint } from '../../server/memory/models/base-schema';
import useMemory from '../../hooks/useMemory';
import ReactMarkdown from 'react-markdown';
import { BaseMetadata, MemoryEditMetadata } from '../../types/metadata';

// Import dialog components directly from source file
import * as DialogPrimitive from "@radix-ui/react-dialog";

// Create dialog components directly for use in this file
const Dialog = DialogPrimitive.Root;
const DialogTrigger = DialogPrimitive.Trigger;
const DialogPortal = DialogPrimitive.Portal;
const DialogClose = DialogPrimitive.Close;
const DialogOverlay = DialogPrimitive.Overlay;
const DialogContent = DialogPrimitive.Content;
const DialogTitle = DialogPrimitive.Title;
const DialogDescription = DialogPrimitive.Description;

// Create simple dialog footer and header
const DialogHeader: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({ className, ...props }) => (
  <div className="flex flex-col space-y-1.5 text-center sm:text-left" {...props} />
);

const DialogFooter: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({ className, ...props }) => (
  <div className="flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2" {...props} />
);

// Create simple button component
const Button: React.FC<React.ButtonHTMLAttributes<HTMLButtonElement> & {
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
  size?: 'default' | 'sm' | 'lg' | 'icon';
}> = ({ 
  children, 
  className,
  variant = 'default',
  size = 'default',
  ...props 
}) => {
  // Simple mapping of variants to classes
  const variantClasses = {
    default: "bg-blue-600 text-white hover:bg-blue-700",
    destructive: "bg-red-600 text-white hover:bg-red-700",
    outline: "bg-transparent border border-gray-300 hover:bg-gray-100",
    secondary: "bg-gray-200 text-gray-900 hover:bg-gray-300",
    ghost: "bg-transparent hover:bg-gray-100",
    link: "bg-transparent text-blue-600 hover:underline"
  };
  
  // Simple mapping of sizes to classes
  const sizeClasses = {
    default: "h-9 px-4 py-2",
    sm: "h-8 text-sm px-3 py-1",
    lg: "h-11 px-8 py-3",
    icon: "h-9 w-9 p-2"
  };
  
  const buttonClasses = `inline-flex items-center justify-center rounded-md font-medium transition-colors 
    ${variantClasses[variant]} ${sizeClasses[size]} ${className || ''}`;
  
  return (
    <button className={buttonClasses} {...props}>
      {children}
    </button>
  );
};

// Create simple alert function instead of using toast to reduce dependencies
const toast = (props: { title?: string; description?: string; variant?: 'default' | 'destructive' }) => {
  // Log to console
  console.log(`Toast: ${props.title} - ${props.description}`);
  
  // Use browser alert for now
  if (props.title && props.description) {
    alert(`${props.title}: ${props.description}`);
  } else if (props.title) {
    alert(props.title);
  } else if (props.description) {
    alert(props.description);
  }
};

// Define UI-specific metadata extensions to handle custom UI fields
interface ExtendedUIMetadata extends BaseMetadata {
  // UI-specific tags and display fields
  autoGeneratedTags?: boolean;
  suggestedTags?: string[];
  type?: string;
  category?: string;
  related_versions?: RelatedVersion[];
}

// Define memory edit record type to match the standardized schema
interface MemoryEditSchema extends BaseMemorySchema {
  metadata: MemoryEditMetadata;
}

interface MemoryEditRecord {
  id: string;
  payload: MemoryEditSchema;
}

// Related version interface
interface RelatedVersion {
  id: string;
  type: string;
  timestamp: string;
  text?: string;
  content?: string;
  error?: boolean;
}

interface MemoryItemProps {
  memory: MemoryPoint<BaseMemorySchema> & {
    kind?: string;
    metadata?: Record<string, any>;
  };
  onTagUpdate: (memoryId: string, tags: string[]) => void;
  onTagSuggestionRemove: (memoryId: string) => void;
  regenerateTagsForMemory?: (memoryId: string, content: string) => Promise<string[]>;
}

/**
 * Component for displaying a single memory item with tag approval
 */
const MemoryItem: React.FC<MemoryItemProps> = ({
  memory,
  onTagUpdate,
  onTagSuggestionRemove,
  regenerateTagsForMemory
}) => {
  // Log when the component renders to debug if regenerateTagsForMemory is available
  console.log(`MemoryItem ${memory.id} render: regenerateTagsForMemory available?`, !!regenerateTagsForMemory);
  
  // Use memory hook for version history
  const { getMemory } = useMemory();
  
  const [expanded, setExpanded] = useState(false);
  const [showSuggestions, setShowSuggestions] = useState(true);
  const [historyExpanded, setHistoryExpanded] = useState(false);
  const [memoryHistory, setMemoryHistory] = useState<MemoryEditRecord[]>([]);
  const [isLoadingHistory, setIsLoadingHistory] = useState(false);
  const [selectedVersion, setSelectedVersion] = useState<RelatedVersion | null>(null);
  const [isLoadingVersion, setIsLoadingVersion] = useState(false);
  const [isRegeneratingTags, setIsRegeneratingTags] = useState(false);
  const [regenerateDialogOpen, setRegenerateDialogOpen] = useState(false);
  
  // Cast the metadata to our extended UI-specific interface
  const uiMetadata = memory.payload?.metadata as ExtendedUIMetadata;
  
  // Check if this memory has auto-generated tags that need approval
  const hasAutoGeneratedTags = uiMetadata?.autoGeneratedTags === true;
  
  // Extract suggested tags vs. manually added tags
  const manualTags = hasAutoGeneratedTags 
    ? uiMetadata?.tags?.filter(tag => !(uiMetadata?.suggestedTags || []).includes(tag)) || []
    : uiMetadata?.tags || [];
  
  const suggestedTags = hasAutoGeneratedTags 
    ? (uiMetadata?.suggestedTags || []).filter(Boolean)
    : [];

  // Ensure we have a valid ID
  const memoryId = memory.id || `memory-${Date.now()}`;

  // Get the memory type from all possible fields with priority to standardized location
  const memoryType = useMemo(() => {
    // Check all possible type fields in priority order
    return memory.payload?.type || 
           memory.kind || 
           uiMetadata?.type || 
           uiMetadata?.category ||
           'unknown';
  }, [memory, uiMetadata]);

  // Create a current version object for reference
  const currentVersion: RelatedVersion = {
    id: memoryId,
    type: memoryType,
    timestamp: memory.payload?.timestamp || new Date().toISOString(),
    text: memory.payload?.text
  };

  // Format date for history items
  const formatHistoryDate = (timestamp: string) => {
    try {
      return new Date(timestamp).toLocaleString();
    } catch (e) {
      return timestamp;
    }
  };
  
  // Get all related versions from metadata
  const relatedVersions = uiMetadata?.related_versions 
    ? uiMetadata.related_versions
    : [];

  // Fetch memory history from the API
  const loadMemoryHistory = useCallback(async () => {
    if (!memoryId || memoryId.startsWith('memory-')) return;
    
    setIsLoadingHistory(true);
    try {
      console.log(`Loading memory history for ${memoryId}`);
      const response = await fetch(`/api/memory/history/${memoryId}`);
      if (response.ok) {
        const data = await response.json();
        console.log(`Received ${data.history?.length || 0} history items for memory ${memoryId}`);
        
        if (data.history && data.history.length > 0) {
          // Sort by timestamp (oldest first)
          data.history.sort((a: MemoryEditRecord, b: MemoryEditRecord) => 
            new Date(a.payload.timestamp).getTime() - new Date(b.payload.timestamp).getTime()
          );
          setMemoryHistory(data.history);
        } else {
          console.log('No history items found');
        }
      } else {
        console.error('Failed to load memory history:', await response.text());
      }
    } catch (error) {
      console.error('Error loading memory history:', error);
    } finally {
      setIsLoadingHistory(false);
    }
  }, [memoryId]);
  
  // Load a specific version of a memory
  const loadVersionContent = async (versionId: string) => {
    if (!versionId || versionId.startsWith('memory-')) return null;
    
    setIsLoadingVersion(true);
    try {
      // Use the standardized memory hook to get the memory by ID
      const memoryData = await getMemory(versionId);
      
      if (memoryData && memoryData.id === versionId) {
        return memoryData;
      } else {
        console.warn(`No data returned for version ID: ${versionId}`);
        return { 
          id: versionId,
          payload: {
            text: 'Content not available for this version',
            timestamp: new Date().toISOString(),
            type: 'unknown',
            metadata: { notFound: true }
          }
        };
      }
    } catch (error) {
      console.error('Error loading version content:', error);
      return { 
        id: versionId,
        payload: {
          text: `Error loading content: ${error instanceof Error ? error.message : 'Unknown error'}`,
          timestamp: new Date().toISOString(),
          type: 'error',
          metadata: { error: true }
        }
      };
    } finally {
      setIsLoadingVersion(false);
    }
  };

  // Handle selecting a specific version
  const handleSelectVersion = async (version: RelatedVersion) => {
    try {
      // Don't reload if it's the same version
      if (selectedVersion && selectedVersion.id === version.id) {
        setSelectedVersion(null);
        return;
      }
      
      // If it's the current version, just select it
      if (version.id === memoryId) {
        setSelectedVersion(currentVersion);
        return;
      }
      
      // Load the version data from the API
      const versionData = await loadVersionContent(version.id);
      
      if (versionData) {
        // Create a RelatedVersion object from the memory data
        const loadedVersion: RelatedVersion = {
          id: versionData.id,
          type: versionData.payload?.type || 'unknown',
          timestamp: versionData.payload?.timestamp || new Date().toISOString(),
          text: versionData.payload?.text,
          error: versionData.payload?.metadata?.error
        };
        
        setSelectedVersion(loadedVersion);
      } else {
        console.error('Failed to load version data');
        setSelectedVersion({
          ...version,
          error: true,
          text: 'Failed to load version data'
        });
      }
    } catch (error) {
      console.error('Error selecting version:', error);
      setSelectedVersion({
        ...version,
        error: true,
        text: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`
      });
    }
  };

  const resetToCurrentVersion = () => {
    setSelectedVersion(null);
  };

  const handleTagApproval = (memoryId: string, approvedTags: string[]) => {
    // Call the parent's onTagUpdate function
    onTagUpdate(memoryId, approvedTags);
    
    // Hide the suggestions after approval
    setShowSuggestions(false);
  };

  const handleTagRejection = (memoryId: string) => {
    // Call the parent's onTagSuggestionRemove function
    onTagSuggestionRemove(memoryId);
    
    // Hide the suggestions after rejection
    setShowSuggestions(false);
  };

  // Format timestamp to a friendly format
  const formattedTimestamp = useMemo(() => {
    if (!memory.payload?.timestamp || memory.payload.timestamp === '') return 'Unknown date';
    
    try {
      const timestamp = memory.payload.timestamp;
      // Check if it's a unix timestamp (number)
      if (!isNaN(Number(timestamp))) {
        // If it's a 13-digit timestamp (milliseconds), use as is
        // If it's a 10-digit timestamp (seconds), multiply by 1000
        const timeMs = timestamp.length >= 13 ? Number(timestamp) : Number(timestamp) * 1000;
        return new Date(timeMs).toLocaleString();
      }
      
      // Otherwise try to parse as ISO string
      const date = new Date(timestamp);
      if (isNaN(date.getTime())) {
        return 'Unknown date';
      }
      return date.toLocaleString();
    } catch (e) {
      return 'Invalid date';
    }
  }, [memory.payload?.timestamp]);

  // Format memory type for display
  const formattedType = useMemo(() => {
    return memoryType.replace(/_/g, ' ').toLowerCase();
  }, [memoryType]);

  // Toggle expanded state
  const toggleExpanded = () => setExpanded(!expanded);

  // Load history when history is expanded
  useEffect(() => {
    if (historyExpanded && memoryHistory.length === 0) {
      loadMemoryHistory();
    }
  }, [historyExpanded, memoryHistory.length, loadMemoryHistory]);

  // Determine CSS classes based on memory type
  const getTypeClasses = (type: string): string => {
    const baseClasses = "text-xs font-medium px-2 py-0.5 rounded-full";
    
    // Create a mapping of memory types to CSS classes
    const typeMap: Record<string, string> = {
      // Use enum values safely with indexing
      [MemoryType.MESSAGE as string]: "bg-blue-100 text-blue-800",
      // Map standard and legacy memory types to CSS classes
      "message": "bg-blue-100 text-blue-800",
      "reflection": "bg-purple-100 text-purple-800",
      "task": "bg-green-100 text-green-800",
      "insight": "bg-amber-100 text-amber-800",
      "plan": "bg-indigo-100 text-indigo-800",
      "memory_edit": "bg-gray-100 text-gray-800",
      "fact": "bg-red-100 text-red-800",
      "knowledge": "bg-teal-100 text-teal-800",
      "system_learning": "bg-cyan-100 text-cyan-800",
      "decision": "bg-orange-100 text-orange-800",
      "feedback": "bg-rose-100 text-rose-800",
      "unknown": "bg-gray-100 text-gray-800",
      "chat": "bg-blue-100 text-blue-800",
      "idea": "bg-green-100 text-green-800",
      "summary": "bg-yellow-100 text-yellow-800"
    };

    return `${baseClasses} ${typeMap[type] || "bg-gray-100 text-gray-800"}`;
  };

  // Add this function near the beginning of the component
  const getTypeColor = (type: string) => {
    // Normalize the type to lowercase for consistent matching
    const normalizedType = type.toLowerCase();
    
    // Define color schemes for different memory types
    if (normalizedType.includes('document')) {
      return { bg: '#134e4a', text: '#5eead4' }; // Teal
    } else if (normalizedType.includes('thought')) {
      return { bg: '#1e3a8a', text: '#93c5fd' }; // Blue
    } else if (normalizedType.includes('message')) {
      return { bg: '#365314', text: '#bef264' }; // Green
    } else if (normalizedType.includes('task')) {
      return { bg: '#713f12', text: '#fcd34d' }; // Yellow
    } else if (normalizedType.includes('reflection')) {
      return { bg: '#581c87', text: '#d8b4fe' }; // Purple
    } else if (normalizedType.includes('edit')) {
      return { bg: '#881337', text: '#fda4af' }; // Red
    } else if (normalizedType.includes('fact') || normalizedType.includes('knowledge')) {
      return { bg: '#1e40af', text: '#93c5fd' }; // Blue
    } else if (normalizedType.includes('summary')) {
      return { bg: '#3f3f46', text: '#d4d4d8' }; // Gray
    }
    
    // Default color scheme
    return { bg: '#1f2937', text: '#9ca3af' };
  };

  // Handle tag regeneration
  const handleRegenerateTags = async () => {
    console.log("DEBUG: handleRegenerateTags called");
    
    if (!memory.payload?.text) {
      console.error("Cannot regenerate tags: missing content");
      toast({
        title: "Error",
        description: "Cannot regenerate tags: memory has no content",
        variant: "destructive"
      });
      return;
    }
    
    console.log("DEBUG: Starting tag regeneration for:", memory.id);
    console.log("DEBUG: Content length:", memory.payload.text.length);
    setIsRegeneratingTags(true);
    
    try {
      // Perform client-side tag generation
      console.log("DEBUG: Performing client-side tag generation");
      
      // Get content from memory
      const content = memory.payload.text;
      
      // Extract unique words, filter out common words and short words
      const words = content.toLowerCase()
        .replace(/[^\w\s]/g, '')
        .split(/\s+/)
        .filter(word => 
          word.length > 5 &&
          !['about', 'there', 'these', 'their', 'would', 'should', 'could'].includes(word)
        );
        
      // Get unique words
      const uniqueWords = Array.from(new Set(words));
      
      // Use the most frequent words as tags
      const wordCounts: Record<string, number> = {};
      words.forEach(word => {
        wordCounts[word] = (wordCounts[word] || 0) + 1;
      });
      
      // Sort by frequency and take the top ones
      const sortedWords = Object.keys(wordCounts)
        .sort((a, b) => wordCounts[b] - wordCounts[a])
        .slice(0, 7);
      
      // Add some standard tags
      const generatedTags = [
        ...sortedWords,
        'memory',
        'content',
        new Date().toISOString().substring(0, 10)
      ];
      
      console.log("DEBUG: Generated tags:", generatedTags);
      
      // Update the memory with the tags
      onTagUpdate(memory.id, generatedTags);
      
      // Show success message
      toast({
        title: "Tags regenerated",
        description: `Generated ${generatedTags.length} tags using client-side processing`,
        variant: "default"
      });
    } catch (error) {
      console.error('DEBUG: Error in handleRegenerateTags:', error);
      
      // Generate fallback tags
      const fallbackTags = ["generated", "fallback", "tags", "memory", "content"];
      
      // Update with fallback tags
      onTagUpdate(memory.id, fallbackTags);
      
      toast({
        title: "Using fallback tags",
        description: "Generated basic tags due to an error",
        variant: "default"
      });
    } finally {
      setIsRegeneratingTags(false);
    }
  };

  return (
    <div className="rounded-lg shadow-sm bg-gray-800 border border-gray-700 overflow-hidden">
      {/* Memory Header - Simplified */}
      <div 
        className="flex flex-col cursor-pointer"
        onClick={toggleExpanded}
      >
        {/* Header Row */}
        <div className="flex items-center justify-between p-2 bg-gray-900">
          <div className="flex items-center space-x-2">
            <div className="text-xs font-semibold px-1.5 py-0.5 rounded-sm" 
                 style={{
                   backgroundColor: memoryType ? getTypeColor(memoryType).bg : '#1e293b',
                   color: memoryType ? getTypeColor(memoryType).text : '#94a3b8'
                 }}>
              {memoryType || 'unknown'}
            </div>
            <div className="text-xs text-gray-400 flex items-center gap-1">
              <Clock className="h-3 w-3" />
              <span>{formattedTimestamp}</span>
            </div>
          </div>
          
          {/* Expand/Collapse Button */}
          <div>
            {expanded ? (
              <ChevronUp className="h-4 w-4 text-gray-400" />
            ) : (
              <ChevronDown className="h-4 w-4 text-gray-400" />
            )}
          </div>
        </div>
        
        {/* Message Content - Just the text in a nice format */}
        <div className={`p-3 text-gray-200 ${!expanded ? 'max-h-60 overflow-hidden relative' : ''}`}>
          {!expanded && (
            <div className="absolute bottom-0 left-0 right-0 h-12 bg-gradient-to-t from-gray-800 to-transparent" />
          )}
          <ReactMarkdown className="prose prose-invert prose-sm max-w-none prose-headings:text-white prose-p:text-gray-200 prose-strong:text-blue-300 prose-a:text-blue-400 prose-code:text-emerald-300 prose-pre:bg-gray-900 prose-pre:text-gray-200">
            {memory.payload?.text || 'No content available'}
          </ReactMarkdown>
        </div>
      </div>
      
      {/* Memory Expanded Content */}
      {expanded && (
        <div className="p-3 border-t border-gray-700 bg-gray-900">
          {/* Raw JSON Structure */}
          <div className="whitespace-pre-wrap text-gray-300 font-mono text-xs mb-4 p-3 bg-gray-950 rounded-md overflow-auto max-h-96">
            {(() => {
              try {
                // Format the entire memory object as JSON
                return JSON.stringify({
                  id: memory.id,
                  type: memoryType,
                  timestamp: memory.payload?.timestamp,
                  payload: memory.payload
                }, null, 2);
              } catch (e) {
                // Fallback for any serialization errors
                return `Error displaying memory structure: ${e instanceof Error ? e.message : 'Unknown error'}`;
              }
            })()}
          </div>
          
          {/* Tags Section */}
          <div className="mb-4">
            <div className="flex items-center justify-between mb-1">
              <div className="flex items-center">
                <Tag className="h-4 w-4 text-gray-400 mr-1" />
                <span className="text-sm font-medium text-gray-300">Tags</span>
              </div>
              
              {/* ALWAYS show regenerate button */}
              <button
                className="flex items-center text-sm bg-blue-600 hover:bg-blue-700 text-white px-3 py-1.5 rounded-md transition-colors font-medium"
                onClick={(e) => {
                  e.stopPropagation();
                  console.log("DEBUG: Regenerate tags button clicked directly");
                  // Use updated function that handles all cases internally
                  handleRegenerateTags();
                }}
                disabled={isRegeneratingTags}
              >
                {isRegeneratingTags ? (
                  <>
                    <RefreshCw className="h-4 w-4 mr-1.5 animate-spin" />
                    Processing...
                  </>
                ) : (
                  <>
                    <Sparkles className="h-4 w-4 mr-1.5" />
                    Regenerate Tags
                  </>
                )}
              </button>
            </div>
            
            {/* Display manual tags */}
            <div className="flex flex-wrap gap-1 mb-2 max-h-40 overflow-y-auto p-1">
              {manualTags.length > 0 ? (
                manualTags.map((tag, index) => (
                  <span key={index} className="bg-gray-700 text-gray-200 text-xs px-2.5 py-0.5 rounded-full">
                    {tag}
                  </span>
                ))
              ) : (
                <span className="text-xs text-gray-500 italic">No tags</span>
              )}
            </div>
          </div>
          
          {/* Memory Metadata */}
          {memory.payload?.metadata && Object.keys(memory.payload.metadata).length > 0 && (
            <div className="mb-4">
              <div className="flex items-center mb-1">
                <Info className="h-4 w-4 text-gray-400 mr-1" />
                <span className="text-sm font-medium text-gray-300">Metadata</span>
              </div>
              
              <div className="grid grid-cols-2 gap-2 text-xs bg-gray-800 p-2 rounded">
                {Object.entries(memory.payload.metadata)
                  .filter(([key]) => !['suggestedTags', 'tags', 'related_versions'].includes(key))
                  .map(([key, value]) => (
                    <div key={key} className="flex">
                      <div className="font-medium text-gray-400 mr-1">{key}:</div>
                      <div className="text-gray-300">
                        {typeof value === 'object' 
                          ? JSON.stringify(value).substring(0, 50) 
                          : String(value).substring(0, 50)}
                      </div>
                    </div>
                  ))
                }
              </div>
            </div>
          )}
          
          {/* Memory History Toggle */}
          <div className="mt-3">
            <button 
              onClick={(e) => {
                e.stopPropagation();
                setHistoryExpanded(!historyExpanded);
              }}
              className="flex items-center text-xs text-blue-400 hover:text-blue-300 transition-colors"
            >
              {historyExpanded ? (
                <>
                  <ChevronUp className="h-3 w-3 mr-1" />
                  Hide Version History
                </>
              ) : (
                <>
                  <ChevronDown className="h-3 w-3 mr-1" />
                  Show Version History
                </>
              )}
            </button>
            
            {/* Memory History Content */}
            {historyExpanded && (
              <div className="mt-2 border-t border-gray-700 pt-2">
                {isLoadingHistory ? (
                  <div className="text-center py-2">
                    <RefreshCw className="h-4 w-4 animate-spin inline mr-1" />
                    <span className="text-xs text-gray-400">Loading history...</span>
                  </div>
                ) : memoryHistory.length === 0 ? (
                  <div className="text-xs text-gray-500 italic">No version history available</div>
                ) : (
                  <div className="space-y-2">
                    <div className="text-xs font-medium text-gray-300">Version History:</div>
                    
                    {/* Current Version */}
                    <div 
                      className={`text-xs p-2 rounded ${selectedVersion?.id === currentVersion.id ? 'bg-blue-900 border border-blue-700' : 'bg-gray-800 hover:bg-gray-700 cursor-pointer border border-gray-700'}`}
                      onClick={() => handleSelectVersion(currentVersion)}
                    >
                      <div className="flex justify-between mb-1">
                        <span className="font-medium text-gray-300">Current Version</span>
                        <span className="text-gray-400">{formatHistoryDate(currentVersion.timestamp)}</span>
                      </div>
                    </div>
                    
                    {/* Previous versions */}
                    {memoryHistory.map((historyItem) => (
                      <div
                        key={historyItem.id}
                        className={`text-xs p-2 rounded ${selectedVersion?.id === historyItem.id ? 'bg-blue-900 border border-blue-700' : 'bg-gray-800 hover:bg-gray-700 cursor-pointer border border-gray-700'}`}
                        onClick={() => handleSelectVersion({
                          id: historyItem.id,
                          type: historyItem.payload?.type || 'unknown',
                          timestamp: historyItem.payload?.timestamp || '',
                        })}
                      >
                        <div className="flex justify-between mb-1">
                          <span className="font-medium text-gray-300">
                            {historyItem.payload?.metadata?.edit_type === 'create' ? 'Created' : 
                             historyItem.payload?.metadata?.edit_type === 'update' ? 'Updated' : 
                             historyItem.payload?.metadata?.edit_type === 'delete' ? 'Deleted' : 
                             'Edit'}
                          </span>
                          <span className="text-gray-400">{formatHistoryDate(historyItem.payload?.timestamp || '')}</span>
                        </div>
                        
                        {historyItem.payload?.metadata?.diff_summary && (
                          <div className="text-gray-400 text-xs mt-1 italic">
                            {historyItem.payload.metadata.diff_summary}
                          </div>
                        )}
                        
                        {historyItem.payload?.metadata?.editor_type && (
                          <div className="text-xs text-gray-500 mt-1">
                            By: {historyItem.payload.metadata.editor_type} 
                            {historyItem.payload.metadata.editor_id ? ` (${historyItem.payload.metadata.editor_id})` : ''}
                          </div>
                        )}
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}
          </div>
          
          {/* Selected Version Display */}
          {selectedVersion && (
            <div className="mt-4 pt-3 border-t border-gray-700">
              <div className="flex justify-between items-center mb-2">
                <div className="text-xs font-medium text-gray-300">
                  {selectedVersion.id === currentVersion.id ? 'Current Version' : 'Historical Version'}
                </div>
                
                <button 
                  onClick={resetToCurrentVersion}
                  className="flex items-center text-xs text-blue-400 hover:text-blue-300 transition-colors"
                >
                  <RotateCcw className="h-3 w-3 mr-1" />
                  Back to Current
                </button>
              </div>
              
              {isLoadingVersion ? (
                <div className="text-center py-2">
                  <RefreshCw className="h-4 w-4 animate-spin inline mr-1" />
                  <span className="text-xs text-gray-400">Loading version content...</span>
                </div>
              ) : (
                <div className="bg-gray-950 p-3 rounded font-mono text-xs whitespace-pre-wrap text-gray-300">
                  {selectedVersion.error ? (
                    <div className="text-red-400">{selectedVersion.text}</div>
                  ) : (
                    selectedVersion.text || 'No content available'
                  )}
                </div>
              )}
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default MemoryItem; 