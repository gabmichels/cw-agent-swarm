import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { Tag, Info, Calendar, Clock, ChevronDown, ChevronUp, Edit, RefreshCw, RotateCcw } from 'lucide-react';
import SuggestedTagsApproval from '../tags/SuggestedTagsApproval';
import { MemoryItem as MemoryItemType } from '../../types';

// Define memory edit record type to match the backend
interface MemoryEditRecord {
  id: string;
  text: string;
  timestamp: string;
  type: string;
  metadata: Record<string, any>;
  original_memory_id: string;
  edit_type: 'create' | 'update' | 'delete';
  editor_type: 'human' | 'agent' | 'system';
  editor_id?: string;
  diff_summary?: string;
  current: boolean;
  previous_version_id?: string;
}

// Related version interface
interface RelatedVersion {
  id: string;
  type: string;
  timestamp: string;
  text?: string;
  content?: string;
  error?: boolean;
}

interface MemoryItemProps {
  memory: MemoryItemType & {
    kind?: string;
    metadata?: Record<string, any>;
  };
  onTagUpdate: (memoryId: string, tags: string[]) => void;
  onTagSuggestionRemove: (memoryId: string) => void;
}

/**
 * Component for displaying a single memory item with tag approval
 */
const MemoryItem: React.FC<MemoryItemProps> = ({
  memory,
  onTagUpdate,
  onTagSuggestionRemove
}) => {
  const [expanded, setExpanded] = useState(false);
  const [showSuggestions, setShowSuggestions] = useState(true);
  const [historyExpanded, setHistoryExpanded] = useState(false);
  const [memoryHistory, setMemoryHistory] = useState<MemoryEditRecord[]>([]);
  const [isLoadingHistory, setIsLoadingHistory] = useState(false);
  const [selectedVersion, setSelectedVersion] = useState<RelatedVersion | null>(null);
  const [isLoadingVersion, setIsLoadingVersion] = useState(false);
  
  // Check if this memory has auto-generated tags that need approval
  const hasAutoGeneratedTags = memory.metadata?.autoGeneratedTags === true;
  
  // Extract suggested tags vs. manually added tags
  const manualTags = hasAutoGeneratedTags 
    ? memory.tags?.filter(tag => !(memory.metadata?.suggestedTags || []).includes(tag)) || []
    : memory.tags || [];
  
  const suggestedTags = hasAutoGeneratedTags 
    ? (memory.metadata?.suggestedTags || []).filter(Boolean)
    : [];

  // Ensure we have a valid ID
  const memoryId = memory.id || `memory-${Date.now()}`;

  // Get the memory type from all possible fields
  const memoryType = useMemo(() => {
    // Check all possible type fields in priority order
    return memory.kind || 
           memory.metadata?.type || 
           memory.category || 
           (memory as any).type || 
           'unknown';
  }, [memory]);

  // Create a current version object for reference
  const currentVersion: RelatedVersion = {
    id: memoryId,
    type: memoryType,
    timestamp: memory.created || memory.timestamp || new Date().toISOString(),
    text: memory.content
  };

  // Format date for history items
  const formatHistoryDate = (timestamp: string) => {
    try {
      return new Date(timestamp).toLocaleString();
    } catch (e) {
      return timestamp;
    }
  };
  
  // Get all related versions from metadata
  const relatedVersions = memory.metadata?.related_versions 
    ? (memory.metadata.related_versions as RelatedVersion[])
    : [];

  // Fetch memory history from the API
  const loadMemoryHistory = useCallback(async () => {
    if (!memoryId || memoryId.startsWith('memory-')) return;
    
    setIsLoadingHistory(true);
    try {
      console.log(`Loading memory history for ${memoryId}`);
      const response = await fetch(`/api/memory/history?id=${memoryId}`);
      if (response.ok) {
        const data = await response.json();
        console.log(`Received ${data.length} history items for memory ${memoryId}`);
        
        if (data.length > 0) {
          // Sort by timestamp (oldest first)
          data.sort((a: MemoryEditRecord, b: MemoryEditRecord) => 
            new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
          );
          setMemoryHistory(data);
        } else {
          console.log('No history items found');
        }
      } else {
        console.error('Failed to load memory history:', await response.text());
      }
    } catch (error) {
      console.error('Error loading memory history:', error);
    } finally {
      setIsLoadingHistory(false);
    }
  }, [memoryId]);
  
  // Load a specific version of a memory
  const loadVersionContent = async (versionId: string) => {
    if (!versionId || versionId.startsWith('memory-')) return null;
    
    setIsLoadingVersion(true);
    try {
      // Use search endpoint to find the specific memory by ID
      const response = await fetch(`/api/memory/search?id=${versionId}`);
      if (response.ok) {
        const data = await response.json();
        console.log('Loaded version data:', data);
        
        // Check if we got a valid response with data
        if (data && Array.isArray(data) && data.length > 0) {
          // Check if the response contains an error object
          if (data[0].metadata?.error) {
            console.error('Server returned error:', data[0].content);
            return { 
              content: `Error loading content: ${data[0].content}`,
              id: versionId,
              metadata: { error: true }
            };
          }
          return data[0];
        } else {
          console.warn(`No data returned for version ID: ${versionId}`);
          return { 
            content: 'Content not available for this version',
            id: versionId,
            metadata: { notFound: true }
          };
        }
      } else {
        console.error('Failed to load version content, status:', response.status);
        return { 
          content: `Failed to load content (status: ${response.status})`,
          id: versionId,
          metadata: { error: true, status: response.status }
        };
      }
    } catch (error) {
      console.error('Error loading version content:', error);
      return { 
        content: `Error loading content: ${error instanceof Error ? error.message : 'Unknown error'}`,
        id: versionId,
        metadata: { error: true }
      };
    } finally {
      setIsLoadingVersion(false);
    }
  };

  // Handle selecting a specific version
  const handleSelectVersion = async (version: RelatedVersion) => {
    try {
      // Don't reload if it's the same version
      if (selectedVersion && selectedVersion.id === version.id) {
        setSelectedVersion(null);
        return;
      }
      
      // Check if content is already loaded
      if (version.text || version.content) {
        setSelectedVersion(version);
        return;
      }
      
      // Load content if needed
      console.log(`Loading content for version: ${version.id}`);
      const versionData = await loadVersionContent(version.id);
      
      if (versionData) {
        const formattedVersion: RelatedVersion = {
          id: version.id,
          type: version.type || versionData.type,
          timestamp: version.timestamp || versionData.timestamp,
          text: versionData.content, // Use the content field from the search result
          error: versionData.metadata?.error
        };
        
        setSelectedVersion(formattedVersion);
      } else {
        // Create error version if loading failed
        const errorVersion: RelatedVersion = {
          id: version.id,
          type: version.type,
          timestamp: version.timestamp,
          text: 'Failed to load version content',
          error: true
        };
        
        setSelectedVersion(errorVersion);
      }
    } catch (error) {
      console.error('Error selecting version:', error);
      // Set error state
      const errorVersion: RelatedVersion = {
        id: version.id,
        type: version.type,
        timestamp: version.timestamp,
        text: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`,
        error: true
      };
      
      setSelectedVersion(errorVersion);
    }
  };

  // Reset to current version
  const resetToCurrentVersion = () => {
    setSelectedVersion(null);
  };

  // Handle tag approval
  const handleTagApproval = (memoryId: string, approvedTags: string[]) => {
    // Combine manually added tags with approved tags
    const updatedTags = [...manualTags, ...approvedTags];
    
    // Update tags via parent component
    onTagUpdate(memoryId, updatedTags);
    
    // Hide the suggestions UI
    setShowSuggestions(false);
  };
  
  // Handle tag suggestion rejection
  const handleTagRejection = (memoryId: string) => {
    onTagSuggestionRemove(memoryId);
    setShowSuggestions(false);
  };
  
  // Format the created date
  const formattedDate = memory.created 
    ? new Date(memory.created).toLocaleString()
    : memory.timestamp
    ? new Date(memory.timestamp).toLocaleString()
    : 'Unknown date';

  // Group metadata by categories for better organization
  const groupedMetadata = React.useMemo(() => {
    if (!memory.metadata) return {};

    // Define metadata categories
    const groups = {
      importance: ['importance', 'importance_score'],
      tags: ['tagsApproved', 'tagConfidence', 'extractedTags'],
      timestamps: ['timestamp', 'created_at', 'updated_at', 'last_updated'],
      content: ['type', 'source', 'role', 'messageType'],
      usage: ['usage_count', 'last_used', 'reinforced', 'last_reinforced_at'],
      status: ['is_deleted', 'current', 'deletion_timestamp'],
      relations: ['previous_version_id', 'led_to', 'caused_by', 'related_versions'],
      editor: ['editor_type', 'editor_id'],
      other: [] as string[]
    };

    // Map for categorizing metadata keys
    const keyToGroup: Record<string, keyof typeof groups> = {};
    
    // Initialize keyToGroup mapping
    Object.entries(groups).forEach(([groupName, keys]) => {
      keys.forEach(key => {
        keyToGroup[key] = groupName as keyof typeof groups;
      });
    });

    // Group metadata by category
    const result: Record<string, Record<string, any>> = {
      importance: {},
      tags: {},
      timestamps: {},
      content: {},
      usage: {},
      status: {},
      relations: {},
      editor: {},
      other: {}
    };

    // Skip these keys from display
    const skippedKeys = ['autoGeneratedTags', 'suggestedTags', '_skip_logging'];

    Object.entries(memory.metadata).forEach(([key, value]) => {
      if (skippedKeys.includes(key)) return;
      
      // Determine which group this key belongs to
      const group = keyToGroup[key] || 'other';
      
      // Add to the appropriate group
      result[group][key] = value;
      
      // If we didn't have a predefined group, remember this key for 'other' category
      if (group === 'other' && !groups.other.includes(key)) {
        groups.other.push(key);
      }
    });

    return result;
  }, [memory.metadata]);

  // Load memory history when expanding history section
  useEffect(() => {
    if (historyExpanded) {
      if (memoryHistory.length === 0) {
        loadMemoryHistory();
      }
    }
  }, [historyExpanded, memoryHistory.length, loadMemoryHistory]);

  // The content to display (either current or selected version)
  const displayContent = useMemo(() => {
    if (selectedVersion) {
      // If selected version has an error, display it with an error indicator
      if (selectedVersion.error) {
        return {
          content: selectedVersion.text || selectedVersion.content || 'Error loading content',
          isError: true
        };
      }
      return {
        content: selectedVersion.text || selectedVersion.content || 'No content available',
        isError: false
      };
    }
    // Default to current memory content
    return {
      content: memory.content,
      isError: false
    };
  }, [selectedVersion, memory.content]);

  return (
    <div className={`bg-gray-800 p-4 rounded-lg shadow-md border ${expanded ? 'border-gray-600' : 'border-gray-700'}`}>
      <div className="flex justify-between items-start mb-2">
        <div className="flex items-start gap-2 flex-wrap">
          {/* Memory type badge */}
          <span className={`px-2 py-1 text-xs rounded-md font-medium ${
            memoryType.includes('thought') ? 'bg-purple-900 text-purple-200' :
            memoryType.includes('message') ? 'bg-blue-900 text-blue-200' :
            memoryType.includes('system') ? 'bg-green-900 text-green-200' :
            memoryType.includes('document') ? 'bg-yellow-900 text-yellow-200' :
            memoryType.includes('task') ? 'bg-red-900 text-red-200' :
            'bg-gray-700 text-gray-300'
          }`}>
            {memoryType}
          </span>
          
          {/* Additional type badges if they exist and are different */}
          {memory.metadata?.type && memory.metadata.type !== memoryType && (
            <span className="px-2 py-1 text-xs rounded-md font-medium bg-gray-700 text-gray-300">
              {memory.metadata.type}
            </span>
          )}
          {memory.category && memory.category !== memoryType && memory.category !== memory.metadata?.type && (
            <span className="px-2 py-1 text-xs rounded-md font-medium bg-gray-700 text-gray-300">
              {memory.category}
            </span>
          )}
          
          {/* Date information */}
          <span className="text-gray-400 text-xs flex items-center">
            <Calendar className="h-3 w-3 mr-1" /> 
            {selectedVersion ? formatHistoryDate(selectedVersion.timestamp) : formattedDate}
          </span>
          
          {/* Show older version indicator if a non-current version is selected */}
          {selectedVersion && (
            <span className="ml-2 px-2 py-0.5 bg-orange-800 text-orange-100 rounded text-xs font-medium">
              OLDER VERSION
            </span>
          )}
        </div>
        
        <div className="flex items-center gap-2">
          {/* Reset button when viewing an older version */}
          {selectedVersion && (
            <button
              onClick={resetToCurrentVersion}
              className="text-blue-400 text-xs hover:text-blue-300 flex items-center"
            >
              <RotateCcw className="h-3 w-3 mr-1" /> Current
            </button>
          )}
          
          <button
            onClick={() => setExpanded(!expanded)}
            className="text-blue-400 text-sm hover:underline flex items-center"
          >
            {expanded ? 'Show Less' : 'Show More'}
            {expanded ? <ChevronUp className="h-3 w-3 ml-1" /> : <ChevronDown className="h-3 w-3 ml-1" />}
          </button>
        </div>
      </div>
      
      {/* Memory content */}
      <div className={`mb-3 ${expanded ? '' : 'line-clamp-3'}`}>
        {isLoadingVersion ? (
          <div className="flex justify-center items-center p-4">
            <RefreshCw className="h-4 w-4 animate-spin text-blue-400 mr-2" />
            <span className="text-sm text-gray-400">Loading version...</span>
          </div>
        ) : displayContent.isError ? (
          <div className="p-2 bg-red-950/30 border border-red-900 rounded">
            <p className="text-sm text-red-300">{displayContent.content}</p>
          </div>
        ) : (
          <p className="text-sm">{displayContent.content}</p>
        )}
      </div>
      
      {/* Display existing tags */}
      {manualTags.length > 0 && !selectedVersion && (
        <div className="mb-3">
          <div className="flex items-center text-xs text-gray-400 mb-1">
            <Tag className="h-3 w-3 mr-1" /> Tags:
          </div>
          <div className="flex flex-wrap gap-1">
            {manualTags.map((tag, index) => (
              <span
                key={`${tag}-${index}`}
                className="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-700 text-gray-200"
              >
                {tag}
              </span>
            ))}
          </div>
        </div>
      )}
      
      {/* Display suggested tags for approval if they exist */}
      {hasAutoGeneratedTags && suggestedTags.length > 0 && showSuggestions && !selectedVersion && (
        <SuggestedTagsApproval
          memoryId={memoryId}
          suggestedTags={suggestedTags}
          existingTags={manualTags}
          onApprove={handleTagApproval}
          onReject={handleTagRejection}
        />
      )}
      
      {/* Metadata section (only when expanded) */}
      {expanded && memory.metadata && Object.keys(memory.metadata).length > 0 && (
        <div className="mt-3 border-t border-gray-700 pt-2">
          <div className="flex items-center text-xs text-gray-400 mb-2">
            <Info className="h-3 w-3 mr-1" /> Metadata:
          </div>
          
          <div className="space-y-3">
            {/* Importance info */}
            {Object.keys(groupedMetadata.importance).length > 0 && (
              <div className="bg-gray-850 rounded p-2">
                <h4 className="text-xs font-semibold text-gray-300 mb-1">Importance</h4>
                <div className="grid grid-cols-2 gap-x-4 gap-y-1">
                  {Object.entries(groupedMetadata.importance).map(([key, value]) => (
                    <div key={key} className="text-xs">
                      <span className="text-gray-400">{key}: </span>
                      <span className="text-gray-200">
                        {typeof value === 'number' ? value.toFixed(2) : String(value)}
                      </span>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Content info */}
            {Object.keys(groupedMetadata.content).length > 0 && (
              <div className="bg-gray-850 rounded p-2">
                <h4 className="text-xs font-semibold text-gray-300 mb-1">Content</h4>
                <div className="grid grid-cols-2 gap-x-4 gap-y-1">
                  {Object.entries(groupedMetadata.content).map(([key, value]) => (
                    <div key={key} className="text-xs">
                      <span className="text-gray-400">{key}: </span>
                      <span className="text-gray-200">{String(value)}</span>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Status info */}
            {Object.keys(groupedMetadata.status).length > 0 && (
              <div className="bg-gray-850 rounded p-2">
                <h4 className="text-xs font-semibold text-gray-300 mb-1">Status</h4>
                <div className="grid grid-cols-2 gap-x-4 gap-y-1">
                  {Object.entries(groupedMetadata.status).map(([key, value]) => (
                    <div key={key} className="text-xs">
                      <span className="text-gray-400">{key}: </span>
                      <span className="text-gray-200">{typeof value === 'boolean' ? (value ? 'Yes' : 'No') : String(value)}</span>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Tags info */}
            {Object.keys(groupedMetadata.tags).length > 0 && (
              <div className="bg-gray-850 rounded p-2">
                <h4 className="text-xs font-semibold text-gray-300 mb-1">Tag Information</h4>
                <div className="grid grid-cols-2 gap-x-4 gap-y-1">
                  {Object.entries(groupedMetadata.tags).map(([key, value]) => (
                    <div key={key} className="text-xs">
                      <span className="text-gray-400">{key}: </span>
                      <span className="text-gray-200">
                        {key === 'tagConfidence' && typeof value === 'number' 
                          ? value.toFixed(2) 
                          : typeof value === 'boolean' 
                            ? (value ? 'Yes' : 'No')
                            : String(value)}
                      </span>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Usage info */}
            {Object.keys(groupedMetadata.usage).length > 0 && (
              <div className="bg-gray-850 rounded p-2">
                <h4 className="text-xs font-semibold text-gray-300 mb-1">Usage</h4>
                <div className="grid grid-cols-2 gap-x-4 gap-y-1">
                  {Object.entries(groupedMetadata.usage).map(([key, value]) => (
                    <div key={key} className="text-xs">
                      <span className="text-gray-400">{key}: </span>
                      <span className="text-gray-200">{String(value)}</span>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Timestamps */}
            {Object.keys(groupedMetadata.timestamps).length > 0 && (
              <div className="bg-gray-850 rounded p-2">
                <h4 className="text-xs font-semibold text-gray-300 mb-1">Timestamps</h4>
                <div className="grid grid-cols-1 gap-y-1">
                  {Object.entries(groupedMetadata.timestamps).map(([key, value]) => (
                    <div key={key} className="text-xs">
                      <span className="text-gray-400">{key}: </span>
                      <span className="text-gray-200">{String(value)}</span>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Relations */}
            {Object.keys(groupedMetadata.relations).length > 0 && (
              <div className="bg-gray-850 rounded p-2">
                <h4 className="text-xs font-semibold text-gray-300 mb-1">Memory Relations</h4>
                <div className="grid grid-cols-1 gap-y-1">
                  {Object.entries(groupedMetadata.relations).map(([key, value]) => (
                    <div key={key} className="text-xs">
                      <span className="text-gray-400">{key}: </span>
                      <span className="text-gray-200">
                        {typeof value === 'object' ? JSON.stringify(value) : String(value)}
                      </span>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Editor */}
            {Object.keys(groupedMetadata.editor).length > 0 && (
              <div className="bg-gray-850 rounded p-2">
                <h4 className="text-xs font-semibold text-gray-300 mb-1">Edited By</h4>
                <div className="grid grid-cols-2 gap-x-4 gap-y-1">
                  {Object.entries(groupedMetadata.editor).map(([key, value]) => (
                    <div key={key} className="text-xs">
                      <span className="text-gray-400">{key}: </span>
                      <span className="text-gray-200">{String(value)}</span>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Other fields */}
            {Object.keys(groupedMetadata.other).length > 0 && (
              <div className="bg-gray-850 rounded p-2">
                <h4 className="text-xs font-semibold text-gray-300 mb-1">Other Metadata</h4>
                <div className="grid grid-cols-2 gap-x-4 gap-y-1">
                  {Object.entries(groupedMetadata.other).map(([key, value]) => (
                    <div key={key} className="text-xs">
                      <span className="text-gray-400">{key}: </span>
                      <span className="text-gray-200">
                        {typeof value === 'object' ? JSON.stringify(value) : String(value)}
                      </span>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
          
          {/* Memory history section */}
          <div className="mt-4 border-t border-gray-700 pt-3">
            <button
              onClick={(e) => {
                e.stopPropagation();
                setHistoryExpanded(!historyExpanded);
              }}
              className="flex items-center gap-2 text-blue-400 hover:text-blue-300 text-sm"
            >
              <RotateCcw size={14} />
              {historyExpanded ? 'Hide Version History' : 'Show Version History'}
            </button>
            
            {/* Version history content */}
            {historyExpanded && (
              <div className="mt-2 text-sm">
                {isLoadingHistory ? (
                  <div className="flex items-center gap-2 text-gray-400">
                    <RefreshCw size={14} className="animate-spin" />
                    Loading history...
                  </div>
                ) : memoryHistory.length === 0 ? (
                  <div className="text-gray-400">No version history available</div>
                ) : (
                  <div className="space-y-2">
                    {/* Current version */}
                    <div className="flex items-center gap-2">
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          resetToCurrentVersion();
                        }}
                        className={`px-2 py-1 rounded text-xs ${
                          selectedVersion === null 
                            ? 'bg-blue-600 text-white' 
                            : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                        }`}
                      >
                        Current Version
                      </button>
                      <span className="text-gray-400 text-xs">
                        {formatHistoryDate(currentVersion.timestamp)}
                      </span>
                    </div>
                    
                    {/* Previous versions */}
                    {memoryHistory.filter(v => !v.current).map((version) => (
                      <div key={version.id} className="flex items-center gap-2">
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            handleSelectVersion({
                              id: version.id,
                              type: version.type,
                              timestamp: version.timestamp,
                              text: version.text
                            });
                          }}
                          className={`px-2 py-1 rounded text-xs ${
                            selectedVersion?.id === version.id
                              ? 'bg-blue-600 text-white'
                              : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                          }`}
                        >
                          {version.edit_type === 'create' ? 'Original' : 
                           version.edit_type === 'update' ? 'Edit' : 
                           version.edit_type === 'delete' ? 'Deleted' : 'Version'}
                        </button>
                        <span className="text-gray-400 text-xs">
                          {formatHistoryDate(version.timestamp)}
                        </span>
                        {version.diff_summary && (
                          <span className="text-gray-500 text-xs italic">
                            {version.diff_summary}
                          </span>
                        )}
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
};

export default MemoryItem; 