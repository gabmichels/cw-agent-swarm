import { IdGenerator } from '@/utils/ulid';
import { Tool, ToolFeedback } from './IToolService';
import { ChatOpenAI } from '@langchain/openai';
import { HumanMessage, SystemMessage } from '@langchain/core/messages';

// Extend the original ToolFeedback interface from IToolService to include error property
interface ExtendedToolFeedback extends ToolFeedback {
  /**
   * Error message if the execution failed
   */
  error?: string;
}

/**
 * Detailed feedback on tool execution
 */
export interface DetailedToolFeedback extends ExtendedToolFeedback {
  /**
   * Context in which the tool was used
   */
  context?: {
    /**
     * Task being performed
     */
    task?: string;
    
    /**
     * User intent 
     */
    intent?: string;
    
    /**
     * Alternative tools considered
     */
    alternativeTools?: string[];
    
    /**
     * Previous tool executions in the chain
     */
    previousTools?: Array<{
      toolId: string;
      result: any;
    }>;
  };
  
  /**
   * Detailed analysis of the result
   */
  resultAnalysis?: {
    /**
     * Whether the result contained the expected information
     */
    containsExpectedInfo: boolean;
    
    /**
     * Whether the result was correctly formatted
     */
    correctFormat: boolean;
    
    /**
     * Whether the result was complete
     */
    isComplete: boolean;
    
    /**
     * Whether the result was actionable
     */
    isActionable: boolean;
    
    /**
     * Time efficiency rating (1-5)
     */
    timeEfficiency: number;
    
    /**
     * Result quality rating (1-5)
     */
    quality: number;
  };
  
  /**
   * Error details if the execution failed
   */
  errorDetails?: {
    /**
     * Error type
     */
    type: 'parameter_error' | 'execution_error' | 'timeout' | 'permission_denied' | 'other';
    
    /**
     * Error message
     */
    message: string;
    
    /**
     * Whether the error was recoverable
     */
    isRecoverable: boolean;
    
    /**
     * Actions taken to recover
     */
    recoveryActions?: string[];
  };
  
  /**
   * Improvement suggestions
   */
  improvements?: Array<{
    /**
     * Type of improvement
     */
    type: 'parameter_selection' | 'tool_selection' | 'error_handling' | 'performance' | 'other';
    
    /**
     * Description of the improvement
     */
    description: string;
    
    /**
     * Priority of the improvement (1-5)
     */
    priority: number;
  }>;
  
  /**
   * User satisfaction with the tool
   */
  userSatisfaction?: number;
  
  /**
   * Whether the feedback was generated by the system or a real user
   */
  feedbackSource: 'system' | 'user' | 'mixed';
}

/**
 * Aggregated feedback statistics for a tool
 */
export interface ToolFeedbackStats {
  /**
   * Tool ID
   */
  toolId: string;
  
  /**
   * Success rate (0-1)
   */
  successRate: number;
  
  /**
   * Average user satisfaction (0-1)
   */
  avgSatisfaction: number;
  
  /**
   * Average execution time in milliseconds
   */
  avgExecutionTime: number;
  
  /**
   * Common failure reasons
   */
  commonFailures: Array<{
    type: string;
    count: number;
    examples: string[];
  }>;
  
  /**
   * Common usages 
   */
  commonUsages: Array<{
    intent: string;
    count: number;
    successRate: number;
  }>;
  
  /**
   * Improvement suggestions
   */
  improvementSuggestions: Array<{
    type: string;
    description: string;
    frequency: number;
    priority: number;
  }>;
  
  /**
   * Feedback count
   */
  totalFeedbackCount: number;
  
  /**
   * Last updated time
   */
  lastUpdated: Date;
}

/**
 * Service for collecting and analyzing tool feedback
 */
export class ToolFeedbackService {
  /**
   * Registry of tool feedback
   */
  private toolFeedback: Map<string, DetailedToolFeedback[]> = new Map();
  
  /**
   * Cached feedback statistics
   */
  private feedbackStats: Map<string, ToolFeedbackStats> = new Map();
  
  /**
   * LLM for feedback analysis
   */
  private llm: ChatOpenAI;
  
  /**
   * Tool registry (for tool metadata)
   */
  private toolRegistry: Map<string, Tool> = new Map();
  
  /**
   * Constructor
   */
  constructor() {
    this.llm = new ChatOpenAI({
      modelName: "gpt-3.5-turbo",
      temperature: 0.1
    });
  }
  
  /**
   * Register a tool with the feedback service
   * @param tool Tool to register
   */
  registerTool(tool: Tool): void {
    this.toolRegistry.set(tool.id, tool);
    
    // Initialize feedback collection for this tool
    if (!this.toolFeedback.has(tool.id)) {
      this.toolFeedback.set(tool.id, []);
    }
  }
  
  /**
   * Record feedback for a tool execution
   * @param feedback Feedback data
   * @returns Whether the feedback was recorded successfully
   */
  async recordFeedback(feedback: ToolFeedback): Promise<boolean> {
    try {
      // Check if tool exists
      if (!this.toolRegistry.has(feedback.toolId)) {
        console.error(`Cannot record feedback for unknown tool: ${feedback.toolId}`);
        return false;
      }
      
      // Create detailed feedback
      const detailedFeedback: DetailedToolFeedback = {
        ...feedback,
        feedbackSource: 'user' // Default to user feedback
      };
      
      // Store the feedback
      if (!this.toolFeedback.has(feedback.toolId)) {
        this.toolFeedback.set(feedback.toolId, []);
      }
      
      this.toolFeedback.get(feedback.toolId)!.push(detailedFeedback);
      
      // Invalidate cached stats
      if (this.feedbackStats.has(feedback.toolId)) {
        this.feedbackStats.delete(feedback.toolId);
      }
      
      console.log(`Recorded feedback for tool ${feedback.toolId}`);
      
      return true;
    } catch (error) {
      console.error('Error recording tool feedback:', error);
      return false;
    }
  }
  
  /**
   * Record detailed feedback for a tool execution with enhanced analysis
   * @param feedback Detailed feedback data
   * @returns Whether the feedback was recorded successfully
   */
  async recordDetailedFeedback(feedback: DetailedToolFeedback): Promise<boolean> {
    try {
      // Check if tool exists
      if (!this.toolRegistry.has(feedback.toolId)) {
        console.error(`Cannot record feedback for unknown tool: ${feedback.toolId}`);
        return false;
      }
      
      // Store the feedback
      if (!this.toolFeedback.has(feedback.toolId)) {
        this.toolFeedback.set(feedback.toolId, []);
      }
      
      this.toolFeedback.get(feedback.toolId)!.push(feedback);
      
      // Invalidate cached stats
      if (this.feedbackStats.has(feedback.toolId)) {
        this.feedbackStats.delete(feedback.toolId);
      }
      
      console.log(`Recorded detailed feedback for tool ${feedback.toolId}`);
      
      return true;
    } catch (error) {
      console.error('Error recording detailed tool feedback:', error);
      return false;
    }
  }
  
  /**
   * Generate automated feedback for a tool execution using LLM
   * @param toolId Tool ID
   * @param executionDetails Execution details
   * @returns Detailed tool feedback
   */
  async generateAutomatedFeedback(
    toolId: string,
    executionDetails: {
      parameters: Record<string, any>;
      result: any;
      executionTime: number;
      wasSuccessful: boolean;
      error?: string;
      context?: {
        task?: string;
        intent?: string;
        alternativeTools?: string[];
        previousTools?: Array<{
          toolId: string;
          result: any;
        }>;
      };
      userId: string;
    }
  ): Promise<DetailedToolFeedback> {
    try {
      console.log(`Generating automated feedback for tool ${toolId}`);
      
      // Check if tool exists
      if (!this.toolRegistry.has(toolId)) {
        throw new Error(`Cannot generate feedback for unknown tool: ${toolId}`);
      }
      
      // Get tool metadata
      const tool = this.toolRegistry.get(toolId)!;
      
      // Generate basic feedback
      const basicFeedback: ExtendedToolFeedback = {
        toolId,
        wasSuccessful: executionDetails.wasSuccessful,
        wasUseful: executionDetails.wasSuccessful, // Assume success equals usefulness initially
        executionTime: executionDetails.executionTime,
        parameters: executionDetails.parameters,
        intent: executionDetails.context?.intent || 'unknown',
        error: executionDetails.error,
        userId: executionDetails.userId
      };
      
      // If execution failed, no need for complex LLM analysis
      if (!executionDetails.wasSuccessful) {
        // Create detailed error-focused feedback
        const detailedFeedback: DetailedToolFeedback = {
          ...basicFeedback,
          feedbackSource: 'system',
          errorDetails: {
            type: 'execution_error',
            message: executionDetails.error || 'Unknown error',
            isRecoverable: false
          },
          resultAnalysis: {
            containsExpectedInfo: false,
            correctFormat: false,
            isComplete: false,
            isActionable: false,
            timeEfficiency: 1,
            quality: 1
          },
          improvements: [
            {
              type: 'error_handling',
              description: `Handle the error: ${executionDetails.error || 'Unknown error'}`,
              priority: 5
            }
          ]
        };
        
        return detailedFeedback;
      }
      
      // For successful executions, use LLM to generate detailed feedback
      const systemPrompt = `You are an AI tool execution analyzer that provides feedback on tool usage.
      
Analyze the execution details of a tool and provide detailed feedback on its effectiveness.
Focus on identifying strengths, weaknesses, and improvement opportunities.

Tool Information:
Name: ${tool.name}
Description: ${tool.description}
Parameters: ${JSON.stringify(tool.parameters)}
Categories: ${tool.categories.join(', ')}

Respond with a JSON object with the following structure:
{
  "resultAnalysis": {
    "containsExpectedInfo": true/false,
    "correctFormat": true/false,
    "isComplete": true/false,
    "isActionable": true/false,
    "timeEfficiency": 1-5,
    "quality": 1-5
  },
  "wasUseful": true/false,
  "improvements": [
    {
      "type": "parameter_selection"/"tool_selection"/"error_handling"/"performance"/"other",
      "description": "Improvement suggestion",
      "priority": 1-5
    }
  ]
}`;

      const humanMessage = `Tool Execution Details:
Tool ID: ${toolId}
Parameters: ${JSON.stringify(executionDetails.parameters)}
Execution Time: ${executionDetails.executionTime}ms
Task: ${executionDetails.context?.task || 'Unknown'}
Intent: ${executionDetails.context?.intent || 'Unknown'}
Result: ${JSON.stringify(executionDetails.result, null, 2)}

Please analyze this tool execution and provide detailed feedback.`;

      // Call LLM
      const messages = [
        new SystemMessage(systemPrompt),
        new HumanMessage(humanMessage)
      ];
      
      // @ts-ignore - LangChain types may not be up to date
      const response = await this.llm.call(messages);
      
      // Parse the response
      const content = response.content.toString();
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      
      if (!jsonMatch) {
        throw new Error('Failed to parse LLM response for tool feedback');
      }
      
      const analysisData = JSON.parse(jsonMatch[0]);
      
      // Create detailed feedback
      const detailedFeedback: DetailedToolFeedback = {
        ...basicFeedback,
        wasUseful: analysisData.wasUseful || basicFeedback.wasUseful,
        resultAnalysis: analysisData.resultAnalysis,
        improvements: analysisData.improvements,
        context: executionDetails.context,
        feedbackSource: 'system'
      };
      
      // Store the feedback
      await this.recordDetailedFeedback(detailedFeedback);
      
      return detailedFeedback;
    } catch (error) {
      console.error('Error generating automated feedback:', error);
      
      // Return basic feedback if analysis fails
      return {
        toolId,
        wasSuccessful: executionDetails.wasSuccessful,
        wasUseful: executionDetails.wasSuccessful,
        executionTime: executionDetails.executionTime,
        parameters: executionDetails.parameters,
        intent: executionDetails.context?.intent || 'unknown',
        error: executionDetails.error,
        userId: executionDetails.userId,
        feedbackSource: 'system'
      };
    }
  }
  
  /**
   * Get feedback statistics for a tool
   * @param toolId Tool ID
   * @returns Feedback statistics
   */
  async getToolFeedbackStats(toolId: string): Promise<ToolFeedbackStats | null> {
    try {
      // Check if tool exists
      if (!this.toolRegistry.has(toolId)) {
        console.error(`Cannot get stats for unknown tool: ${toolId}`);
        return null;
      }
      
      // Check if we have cached stats
      if (this.feedbackStats.has(toolId)) {
        return this.feedbackStats.get(toolId)!;
      }
      
      // Get feedback data
      const feedbackData = this.toolFeedback.get(toolId) || [];
      
      if (feedbackData.length === 0) {
        const emptyStats: ToolFeedbackStats = {
          toolId,
          successRate: 0,
          avgSatisfaction: 0,
          avgExecutionTime: 0,
          commonFailures: [],
          commonUsages: [],
          improvementSuggestions: [],
          totalFeedbackCount: 0,
          lastUpdated: new Date()
        };
        
        this.feedbackStats.set(toolId, emptyStats);
        return emptyStats;
      }
      
      // Calculate statistics
      const totalExecutions = feedbackData.length;
      const successfulExecutions = feedbackData.filter(f => f.wasSuccessful).length;
      const usefulExecutions = feedbackData.filter(f => f.wasUseful).length;
      
      // Success rate
      const successRate = successfulExecutions / totalExecutions;
      
      // Average satisfaction
      const satisfactionData = feedbackData.filter(f => f.userSatisfaction !== undefined);
      const avgSatisfaction = satisfactionData.length > 0
        ? satisfactionData.reduce((sum, f) => sum + (f.userSatisfaction || 0), 0) / satisfactionData.length
        : 0;
      
      // Average execution time
      const avgExecutionTime = feedbackData.reduce((sum, f) => sum + f.executionTime, 0) / totalExecutions;
      
      // Common failures
      const failureMap = new Map<string, { count: number; examples: string[] }>();
      
      for (const feedback of feedbackData.filter(f => !f.wasSuccessful)) {
        const errorType = feedback.errorDetails?.type || 'other';
        const errorMessage = feedback.errorDetails?.message || feedback.error || 'Unknown error';
        
        if (!failureMap.has(errorType)) {
          failureMap.set(errorType, { count: 0, examples: [] });
        }
        
        const failure = failureMap.get(errorType)!;
        failure.count++;
        
        if (failure.examples.length < 3 && !failure.examples.includes(errorMessage)) {
          failure.examples.push(errorMessage);
        }
      }
      
      const commonFailures = Array.from(failureMap.entries())
        .map(([type, { count, examples }]) => ({ type, count, examples }))
        .sort((a, b) => b.count - a.count);
      
      // Common usages
      const usageMap = new Map<string, { count: number; successes: number }>();
      
      for (const feedback of feedbackData) {
        const intent = feedback.intent || 'unknown';
        
        if (!usageMap.has(intent)) {
          usageMap.set(intent, { count: 0, successes: 0 });
        }
        
        const usage = usageMap.get(intent)!;
        usage.count++;
        
        if (feedback.wasSuccessful) {
          usage.successes++;
        }
      }
      
      const commonUsages = Array.from(usageMap.entries())
        .map(([intent, { count, successes }]) => ({
          intent,
          count,
          successRate: count > 0 ? successes / count : 0
        }))
        .sort((a, b) => b.count - a.count);
      
      // Improvement suggestions
      const improvementMap = new Map<string, { description: string; count: number; priority: number }>();
      
      for (const feedback of feedbackData) {
        if (!feedback.improvements) continue;
        
        for (const improvement of feedback.improvements) {
          const key = `${improvement.type}:${improvement.description}`;
          
          if (!improvementMap.has(key)) {
            improvementMap.set(key, {
              description: improvement.description,
              count: 0,
              priority: improvement.priority
            });
          }
          
          const improvementData = improvementMap.get(key)!;
          improvementData.count++;
          
          // Update priority to the average
          improvementData.priority = (improvementData.priority * (improvementData.count - 1) + improvement.priority) / improvementData.count;
        }
      }
      
      const improvementSuggestions = Array.from(improvementMap.entries())
        .map(([key, { description, count, priority }]) => ({
          type: key.split(':', 1)[0],
          description,
          frequency: count,
          priority
        }))
        .sort((a, b) => b.frequency - a.frequency);
      
      // Create stats
      const stats: ToolFeedbackStats = {
        toolId,
        successRate,
        avgSatisfaction,
        avgExecutionTime,
        commonFailures,
        commonUsages,
        improvementSuggestions,
        totalFeedbackCount: totalExecutions,
        lastUpdated: new Date()
      };
      
      // Cache stats
      this.feedbackStats.set(toolId, stats);
      
      return stats;
    } catch (error) {
      console.error(`Error getting feedback stats for tool ${toolId}:`, error);
      return null;
    }
  }
  
  /**
   * Get tool improvement recommendations based on feedback
   * @param toolId Tool ID
   * @returns Prioritized improvement recommendations
   */
  async getToolImprovementRecommendations(
    toolId: string
  ): Promise<Array<{
    type: string;
    description: string;
    priority: number;
    impact: 'low' | 'medium' | 'high';
  }>> {
    try {
      // Get feedback stats
      const stats = await this.getToolFeedbackStats(toolId);
      
      if (!stats) {
        return [];
      }
      
      // If we have enough feedback data, return the improvement suggestions
      if (stats.totalFeedbackCount >= 5 && stats.improvementSuggestions.length > 0) {
        return stats.improvementSuggestions.map(suggestion => {
          // Calculate impact based on frequency and priority
          const frequencyFactor = Math.min(suggestion.frequency / stats.totalFeedbackCount, 1);
          const priorityFactor = suggestion.priority / 5;
          const impactScore = frequencyFactor * priorityFactor;
          
          let impact: 'low' | 'medium' | 'high';
          if (impactScore >= 0.6) {
            impact = 'high';
          } else if (impactScore >= 0.3) {
            impact = 'medium';
          } else {
            impact = 'low';
          }
          
          return {
            type: suggestion.type,
            description: suggestion.description,
            priority: suggestion.priority,
            impact
          };
        }).sort((a, b) => {
          // Sort by impact then priority
          if (a.impact === b.impact) {
            return b.priority - a.priority;
          }
          
          return a.impact === 'high' ? -1 : (a.impact === 'medium' && b.impact === 'low' ? -1 : 1);
        });
      }
      
      // If we don't have enough feedback, return empty array
      return [];
    } catch (error) {
      console.error(`Error getting improvement recommendations for tool ${toolId}:`, error);
      return [];
    }
  }
  
  /**
   * Generate a tool usage report
   * @param toolId Tool ID
   * @returns Tool usage report
   */
  async generateToolUsageReport(
    toolId: string
  ): Promise<{
    toolInfo: {
      id: string;
      name: string;
      description: string;
    };
    usageStats: {
      totalUsage: number;
      successRate: number;
      failureRate: number;
      avgExecutionTime: number;
      usefulnessRate: number;
    };
    topUseCases: Array<{
      intent: string;
      count: number;
      successRate: number;
    }>;
    commonIssues: Array<{
      type: string;
      frequency: number;
      examples: string[];
    }>;
    recommendations: Array<{
      description: string;
      priority: string;
      impact: string;
    }>;
  }> {
    try {
      // Check if tool exists
      const tool = this.toolRegistry.get(toolId);
      
      if (!tool) {
        throw new Error(`Tool ${toolId} not found`);
      }
      
      // Get feedback stats
      const stats = await this.getToolFeedbackStats(toolId);
      
      if (!stats) {
        throw new Error(`No feedback stats for tool ${toolId}`);
      }
      
      // Get improvement recommendations
      const recommendations = await this.getToolImprovementRecommendations(toolId);
      
      // Build report
      return {
        toolInfo: {
          id: tool.id,
          name: tool.name,
          description: tool.description
        },
        usageStats: {
          totalUsage: stats.totalFeedbackCount,
          successRate: stats.successRate,
          failureRate: 1 - stats.successRate,
          avgExecutionTime: stats.avgExecutionTime,
          usefulnessRate: stats.totalFeedbackCount > 0 ? 
            this.toolFeedback.get(toolId)!.filter(f => f.wasUseful).length / stats.totalFeedbackCount : 0
        },
        topUseCases: stats.commonUsages.slice(0, 5),
        commonIssues: stats.commonFailures.map(failure => ({
          type: failure.type,
          frequency: failure.count,
          examples: failure.examples
        })),
        recommendations: recommendations.map(rec => ({
          description: rec.description,
          priority: rec.priority >= 4 ? 'High' : (rec.priority >= 2 ? 'Medium' : 'Low'),
          impact: rec.impact
        }))
      };
    } catch (error) {
      console.error(`Error generating usage report for tool ${toolId}:`, error);
      
      // Return basic report with tool info
      const tool = this.toolRegistry.get(toolId);
      
      return {
        toolInfo: {
          id: toolId,
          name: tool?.name || 'Unknown Tool',
          description: tool?.description || 'No description available'
        },
        usageStats: {
          totalUsage: 0,
          successRate: 0,
          failureRate: 0,
          avgExecutionTime: 0,
          usefulnessRate: 0
        },
        topUseCases: [],
        commonIssues: [],
        recommendations: []
      };
    }
  }
  
  /**
   * Clear feedback data for a tool
   * @param toolId Tool ID
   * @returns Whether the data was cleared successfully
   */
  clearToolFeedback(toolId: string): boolean {
    try {
      if (!this.toolRegistry.has(toolId)) {
        console.error(`Cannot clear feedback for unknown tool: ${toolId}`);
        return false;
      }
      
      // Clear feedback data
      this.toolFeedback.set(toolId, []);
      
      // Clear cached stats
      if (this.feedbackStats.has(toolId)) {
        this.feedbackStats.delete(toolId);
      }
      
      console.log(`Cleared feedback data for tool ${toolId}`);
      
      return true;
    } catch (error) {
      console.error(`Error clearing feedback data for tool ${toolId}:`, error);
      return false;
    }
  }
} 