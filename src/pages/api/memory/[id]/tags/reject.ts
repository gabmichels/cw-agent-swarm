import { NextApiRequest, NextApiResponse } from 'next';
import { getMemoryServices } from '../../../../../server/memory/services';
import { MemoryType } from '../../../../../server/memory/config/types';

type ResponseData = {
  success?: boolean;
  error?: string;
  memoryId?: string;
};

export default async function handler(
  req: NextApiRequest, 
  res: NextApiResponse<ResponseData>
) {
  console.log("DEBUG: /api/memory/[id]/tags/reject API endpoint called");
  console.log("DEBUG: Request method:", req.method);
  console.log("DEBUG: Memory ID:", req.query.id);
  
  // Only accept POST requests
  if (req.method !== 'POST') {
    console.log("DEBUG: Method not allowed:", req.method);
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    // Get memory ID from path
    const memoryId = req.query.id as string;
    
    console.log(`DEBUG: Rejecting tags for memory ${memoryId}`);
    
    // Basic validation
    if (!memoryId) {
      console.log("DEBUG: Missing memoryId in path");
      return res.status(400).json({ error: 'Memory ID is required' });
    }

    // Get memory services
    const { memoryService, client } = await getMemoryServices();
    
    // Try to find the memory in possible collections
    const collections = Object.values(MemoryType).map(type => type.toLowerCase());
    
    let memory = null;
    let memoryType = MemoryType.MESSAGE; // Default to message type if not found
    
    // Try to find the memory in any collection
    for (const collection of collections) {
      try {
        const points = await client.getPoints(collection, [memoryId]);
        if (points && points.length > 0) {
          memory = points[0];
          memoryType = (memory.payload?.type as MemoryType) || memoryType;
          break;
        }
      } catch (err) {
        // Ignore errors for collections that don't exist
        continue;
      }
    }
    
    if (!memory) {
      console.log("DEBUG: Memory not found in any collection");
      return res.status(404).json({ error: 'Memory not found in any collection' });
    }
    
    // Update memory to reject suggested tags
    console.log("DEBUG: Updating memory to reject suggested tags");
    const updateResult = await memoryService.updateMemory({
      id: memoryId,
      type: memoryType,
      metadata: {
        // Preserve existing metadata by spreading it first
        ...(memory.payload?.metadata || {}),
        // Clear suggested tags
        suggestedTags: [],
        // Mark as not auto-generated to prevent future suggestions
        autoGeneratedTags: false,
        // Add flag indicating tags were explicitly rejected
        tagsRejected: true,
        tagsRejectedAt: new Date().toISOString()
      }
    });
    
    if (!updateResult) {
      console.log("DEBUG: Failed to update memory");
      return res.status(500).json({ error: 'Failed to update memory' });
    }
    
    console.log("DEBUG: Successfully rejected tags for memory:", memoryId);

    // Return success
    return res.status(200).json({
      success: true,
      memoryId
    });
  } catch (error) {
    console.error("DEBUG: Error rejecting tags:", error);
    return res.status(500).json({ 
      success: false,
      error: error instanceof Error ? error.message : String(error)
    });
  }
} 