/**
 * API route for bulk tagging memories
 * Supports adding or removing tags for multiple memories based on filters
 */
import { NextRequest, NextResponse } from 'next/server';
import { MemoryType, MemoryErrorCode } from '../../../../server/memory/config';
import { getMemoryServices } from '../../../../server/memory/services';

// Mark as server-side only
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

/**
 * POST handler for bulk tagging
 */
export async function POST(request: NextRequest) {
  try {
    const { 
      tags = [], 
      operation = 'add', 
      filter = {}, 
      types = [],
      limit = 100 
    } = await request.json();
    
    // Validate required fields
    if (!Array.isArray(tags) || tags.length === 0) {
      return NextResponse.json({ 
        success: false, 
        error: 'Tags array is required and must not be empty' 
      }, { status: 400 });
    }
    
    // Validate operations
    if (!['add', 'remove', 'replace'].includes(operation)) {
      return NextResponse.json({ 
        success: false, 
        error: 'Operation must be one of: add, remove, replace' 
      }, { status: 400 });
    }
    
    // Get memory services
    const { searchService, memoryService } = await getMemoryServices();
    
    // Find memories matching the filter
    let memoriesToUpdate;
    
    try {
      // Use the new filter method if filter is provided
      memoriesToUpdate = await searchService.filter({
        filter,
        types: types as MemoryType[],
        limit
      });
    } catch (filterError) {
      console.error('Error finding memories to update:', filterError);
      return NextResponse.json({ 
        success: false, 
        error: 'Failed to find memories matching filter',
        details: filterError instanceof Error ? filterError.message : 'Unknown error'
      }, { status: 500 });
    }
    
    if (!memoriesToUpdate || memoriesToUpdate.length === 0) {
      return NextResponse.json({ 
        success: false, 
        error: 'No memories found matching the filter criteria' 
      }, { status: 404 });
    }
    
    // Process each memory
    const updateResults = [];
    const failedUpdates = [];
    
    for (const memory of memoriesToUpdate) {
      try {
        const memoryId = memory.point.id;
        const existingTags = memory.point.payload.metadata?.tags || [];
        let updatedTags: string[] = [];
        
        switch (operation) {
          case 'add':
            // Add new tags without duplicates
            updatedTags = Array.from(new Set([...existingTags, ...tags]));
            break;
          
          case 'remove':
            // Remove specified tags
            updatedTags = existingTags.filter((tag: any) => !tags.includes(tag));
            break;
          
          case 'replace':
            // Replace all tags
            updatedTags = [...tags];
            break;
        }
        
        // Update the memory with new tags
        const updateResult = await memoryService.updateMemory({
          id: memoryId,
          type: memory.type,
          payload: {
            metadata: {
              tags: updatedTags,
              tagsApproved: true,
              autoGeneratedTags: false
            }
          }
        });
        
        if (updateResult) {
          updateResults.push({
            id: memoryId,
            type: memory.type,
            oldTags: existingTags,
            newTags: updatedTags
          });
        } else {
          failedUpdates.push({
            id: memoryId,
            type: memory.type,
            error: 'Update returned false'
          });
        }
      } catch (updateError) {
        console.error(`Error updating memory ${memory.point.id}:`, updateError);
        failedUpdates.push({
          id: memory.point.id,
          type: memory.type,
          error: updateError instanceof Error ? updateError.message : 'Unknown error'
        });
      }
    }
    
    // Return summary
    return NextResponse.json({
      success: true,
      summary: {
        operation,
        totalMemories: memoriesToUpdate.length,
        updatedCount: updateResults.length,
        failedCount: failedUpdates.length
      },
      updatedMemories: updateResults,
      failedUpdates: failedUpdates.length > 0 ? failedUpdates : undefined
    });
  } catch (error) {
    console.error('Error in bulk tag operation:', error);
    
    // Handle specific memory error types
    if (error && typeof error === 'object' && 'code' in error) {
      const memoryError = error as { code: string; message: string };
      
      if (memoryError.code === MemoryErrorCode.VALIDATION_ERROR) {
        return NextResponse.json({
          success: false,
          error: memoryError.message || 'Invalid parameters'
        }, { status: 400 });
      }
    }
    
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
} 